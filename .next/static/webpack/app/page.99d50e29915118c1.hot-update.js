"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSupabaseData.ts":
/*!**********************************!*\
  !*** ./hooks/useSupabaseData.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSupabaseData: function() { return /* binding */ useSupabaseData; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n\nfunction useSupabaseData(user) {\n    const [songs, setSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [playlists, setPlaylists] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [likedSongs, setLikedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Set());\n    const [lastPlayedSong, setLastPlayedSong] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [currentSongStartTime, setCurrentSongStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const currentSongRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Get personalized songs based on user's actual listening preferences\n    const getSmartPersonalizedSongs = async (userId, listenedSongsInBatch, excludeSongs)=>{\n        try {\n            console.log(\"\\uD83E\\uDDE0 Fetching smart personalized songs based on listening behavior\");\n            console.log(\"\\uD83C\\uDFB5 Songs user actually listened to:\", listenedSongsInBatch.map((s)=>s.name));\n            if (listenedSongsInBatch.length === 0) {\n                console.log(\"⚠️ No listened songs in batch, falling back to regular personalization\");\n                return [];\n            }\n            // Extract tags and artists from listened songs\n            const preferredTags = new Set();\n            const preferredArtists = new Set();\n            listenedSongsInBatch.forEach((song)=>{\n                var _song_tags;\n                (_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.forEach((tag)=>preferredTags.add(tag.toLowerCase()));\n                preferredArtists.add(song.artist.toLowerCase());\n            });\n            console.log(\"\\uD83C\\uDFF7️ Preferred tags:\", Array.from(preferredTags));\n            console.log(\"\\uD83C\\uDFA4 Preferred artists:\", Array.from(preferredArtists));\n            // Fetch all songs from database\n            const { data: songsData, error: songsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"songs\").select(\"*\");\n            if (songsError) {\n                console.error(\"❌ Error fetching songs for smart personalization:\", songsError);\n                return [];\n            }\n            if (!songsData || songsData.length === 0) {\n                console.warn(\"⚠️ No songs found in database\");\n                return [];\n            }\n            // Get user's liked songs\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n            const userLikedSongs = new Set();\n            if (likedData) {\n                likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n            }\n            // Filter and score songs based on listening preferences\n            const availableSongs = songsData.filter((song)=>{\n                return !excludeSongs.has(song.file_id.toString());\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs for smart recommendations: \".concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // Score songs based on user's listening preferences\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // High priority: Tag matching with listened songs\n                const songTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.map((tag)=>tag.toLowerCase())) || [];\n                const matchingTags = songTags.filter((tag)=>preferredTags.has(tag));\n                score += matchingTags.length * 25; // Higher weight for tag matching\n                // High priority: Artist matching with listened songs\n                if (preferredArtists.has(song.artist.toLowerCase())) {\n                    score += 30; // Higher weight for artist matching\n                }\n                // Medium priority: Same language as listened songs\n                const listenedLanguages = listenedSongsInBatch.map((s)=>s.language);\n                if (listenedLanguages.includes(song.language)) {\n                    score += 15;\n                }\n                // Lower priority: General popularity\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Bonus for liked songs\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 10;\n                }\n                // Add small randomness to avoid repetition\n                score += Math.random() * 2;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 15) // Get more songs for variety\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83E\\uDDE0 Smart recommendations based on listening behavior:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getSmartPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Convert database song to UI song format\n    const convertDatabaseSong = function(dbSong) {\n        let isLiked = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return {\n            file_id: dbSong.file_id,\n            img_id: dbSong.img_id,\n            name: dbSong.name,\n            artist: dbSong.artist,\n            language: dbSong.language,\n            tags: dbSong.tags,\n            views: dbSong.views,\n            likes: dbSong.likes,\n            id: dbSong.file_id.toString(),\n            image: \"https://images.pexels.com/photos/\".concat(dbSong.img_id, \"/pexels-photo-\").concat(dbSong.img_id, \".jpeg?auto=compress&cs=tinysrgb&w=300\"),\n            isLiked\n        };\n    };\n    // Fetch all songs\n    const fetchSongs = async ()=>{\n        if (!user) {\n            setSongs([]);\n            return;\n        }\n        try {\n            const { data: songsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"songs\").select(\"*\").order(\"views\", {\n                ascending: false\n            });\n            if (error) throw error;\n            let userLikedSongs = new Set();\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", user.id);\n            if (likedData) {\n                userLikedSongs = new Set(likedData.map((item)=>item.song_id));\n                setLikedSongs(userLikedSongs);\n            }\n            const convertedSongs = (songsData === null || songsData === void 0 ? void 0 : songsData.map((song)=>convertDatabaseSong(song, userLikedSongs.has(song.file_id)))) || [];\n            const sortedSongs = [\n                ...convertedSongs\n            ].sort((a, b)=>{\n                const aScore = a.views + a.likes;\n                const bScore = b.views + b.likes;\n                return bScore - aScore;\n            });\n            setSongs(sortedSongs);\n            const { data: userData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"users\").select(\"last_song_file_id\").eq(\"id\", user.id).single();\n            if (userData === null || userData === void 0 ? void 0 : userData.last_song_file_id) {\n                const lastSong = convertedSongs.find((song)=>song.file_id === userData.last_song_file_id);\n                if (lastSong) {\n                    setLastPlayedSong(lastSong);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching songs:\", error);\n            setSongs([]) // Set empty array on error\n            ;\n        }\n    };\n    // Get personalized songs with proper error handling and filtering\n    const getPersonalizedSongs = async (userId, currentSong, listenedSongs)=>{\n        try {\n            console.log(\"\\uD83C\\uDFB5 Fetching personalized songs for:\", currentSong.name);\n            console.log(\"\\uD83C\\uDFB5 Listened songs count:\", (listenedSongs === null || listenedSongs === void 0 ? void 0 : listenedSongs.size) || 0);\n            // 1. Fetch all songs from database\n            const { data: songsData, error: songsError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"songs\").select(\"*\");\n            if (songsError) {\n                console.error(\"❌ Error fetching songs for personalization:\", songsError);\n                return [];\n            }\n            if (!songsData || songsData.length === 0) {\n                console.warn(\"⚠️ No songs found in database\");\n                return [];\n            }\n            // 2. Fetch user's listening history\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"history\").select(\"song_id, minutes_listened\").eq(\"user_id\", userId);\n            if (historyError) {\n                console.error(\"❌ Error fetching history:\", historyError);\n            }\n            const historyMap = new Map();\n            if (historyData) {\n                historyData.forEach((h)=>historyMap.set(h.song_id, h.minutes_listened || 0));\n            }\n            // 3. Get user's liked songs\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n            const userLikedSongs = new Set();\n            if (likedData) {\n                likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n            }\n            // 4. Filter and score songs\n            const availableSongs = songsData.filter((song)=>{\n                // Exclude current song\n                if (song.file_id === currentSong.file_id) {\n                    return false;\n                }\n                // Exclude listened songs if provided\n                if (listenedSongs && listenedSongs.has(song.file_id.toString())) {\n                    console.log(\"\\uD83D\\uDEAB Excluding listened song: \".concat(song.name, \" by \").concat(song.artist));\n                    return false;\n                }\n                return true;\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs after filtering: \".concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // 5. Score and sort songs\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // Tag matching (highest priority)\n                const matchingTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.filter((tag)=>{\n                    var _currentSong_tags;\n                    return (_currentSong_tags = currentSong.tags) === null || _currentSong_tags === void 0 ? void 0 : _currentSong_tags.includes(tag);\n                })) || [];\n                score += matchingTags.length * 15;\n                // Artist matching\n                if (song.artist === currentSong.artist) {\n                    score += 25;\n                }\n                // Language matching\n                if (song.language === currentSong.language) {\n                    score += 10;\n                }\n                // Listening history boost\n                const listenedMinutes = historyMap.get(song.file_id) || 0;\n                score += Math.min(listenedMinutes * 2, 20); // Cap at 20 points\n                // Popularity boost (likes and views)\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Liked songs boost\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 8;\n                }\n                // Add controlled randomness to avoid repetition\n                score += Math.random() * 3;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // 6. Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 10) // Get more songs to have a buffer\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83C\\uDFB5 Personalized recommendations:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            console.log(\"\\uD83C\\uDFB5 Total available songs:\", availableSongs.length);\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Fetch user playlists\n    const fetchPlaylists = async ()=>{\n        if (!user) {\n            setPlaylists([]);\n            return;\n        }\n        try {\n            const { data: playlistsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").select(\"\\n          id,\\n          name,\\n          playlist_songs (\\n            songs (*)\\n          )\\n        \").eq(\"user_id\", user.id);\n            if (error) throw error;\n            const convertedPlaylists = (playlistsData === null || playlistsData === void 0 ? void 0 : playlistsData.map((playlist)=>{\n                var _playlist_playlist_songs, _playlistSongs_;\n                const playlistSongs = ((_playlist_playlist_songs = playlist.playlist_songs) === null || _playlist_playlist_songs === void 0 ? void 0 : _playlist_playlist_songs.map((ps)=>convertDatabaseSong(ps.songs, likedSongs.has(ps.songs.file_id)))) || [];\n                return {\n                    id: playlist.id.toString(),\n                    name: playlist.name,\n                    songCount: playlistSongs.length,\n                    image: ((_playlistSongs_ = playlistSongs[0]) === null || _playlistSongs_ === void 0 ? void 0 : _playlistSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                    songs: playlistSongs\n                };\n            })) || [];\n            setPlaylists(convertedPlaylists);\n        } catch (error) {\n            console.error(\"Error fetching playlists:\", error);\n        }\n    };\n    // Toggle like song\n    const toggleLike = async (songId)=>{\n        if (!user) return;\n        const songFileId = parseInt(songId);\n        const isCurrentlyLiked = likedSongs.has(songFileId);\n        try {\n            if (isCurrentlyLiked) {\n                // Remove from liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").delete().eq(\"user_id\", user.id).eq(\"song_id\", songFileId);\n                if (error) throw error;\n                // Decrement likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"decrement_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>{\n                    const newSet = new Set(prev);\n                    newSet.delete(songFileId);\n                    return newSet;\n                });\n            } else {\n                // Add to liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").insert({\n                    user_id: user.id,\n                    song_id: songFileId\n                });\n                if (error) throw error;\n                // Increment likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"increment_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>new Set(prev).add(songFileId));\n            }\n            // Update songs state\n            // Update songs state\n            setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                        ...song,\n                        isLiked: !isCurrentlyLiked,\n                        likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                    } : song));\n            // Update playlists state\n            setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                        ...playlist,\n                        songs: playlist.songs.map((song)=>song.id === songId ? {\n                                ...song,\n                                isLiked: !isCurrentlyLiked,\n                                likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                            } : song)\n                    })));\n        } catch (error) {\n            console.error(\"Error toggling like:\", error);\n        }\n    };\n    // Create playlist\n    const createPlaylist = async (name)=>{\n        if (!user) return;\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").insert({\n                user_id: user.id,\n                name\n            }).select().single();\n            if (error) throw error;\n            const newPlaylist = {\n                id: data.id.toString(),\n                name: data.name,\n                songCount: 0,\n                image: \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                songs: []\n            };\n            setPlaylists((prev)=>[\n                    ...prev,\n                    newPlaylist\n                ]);\n        } catch (error) {\n            console.error(\"Error creating playlist:\", error);\n        }\n    };\n    // Delete playlist\n    const deletePlaylist = async (playlistId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").delete().eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.filter((playlist)=>playlist.id !== playlistId));\n        } catch (error) {\n            console.error(\"Error deleting playlist:\", error);\n        }\n    };\n    // Rename playlist\n    const renamePlaylist = async (playlistId, newName)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").update({\n                name: newName\n            }).eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>playlist.id === playlistId ? {\n                        ...playlist,\n                        name: newName\n                    } : playlist));\n        } catch (error) {\n            console.error(\"Error renaming playlist:\", error);\n        }\n    };\n    // Add song to playlist\n    const addSongToPlaylist = async (playlistId, song)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlist_songs\").insert({\n                playlist_id: parseInt(playlistId),\n                song_id: song.file_id\n            });\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        const songExists = playlist.songs.some((s)=>s.id === song.id);\n                        if (!songExists) {\n                            var _updatedSongs_;\n                            const updatedSongs = [\n                                ...playlist.songs,\n                                song\n                            ];\n                            return {\n                                ...playlist,\n                                songs: updatedSongs,\n                                songCount: updatedSongs.length,\n                                image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || playlist.image\n                            };\n                        }\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error adding song to playlist:\", error);\n        }\n    };\n    // Remove song from playlist\n    const removeSongFromPlaylist = async (playlistId, songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlist_songs\").delete().eq(\"playlist_id\", parseInt(playlistId)).eq(\"song_id\", parseInt(songId));\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        var _updatedSongs_;\n                        const updatedSongs = playlist.songs.filter((song)=>song.id !== songId);\n                        return {\n                            ...playlist,\n                            songs: updatedSongs,\n                            songCount: updatedSongs.length,\n                            image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\"\n                        };\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error removing song from playlist:\", error);\n        }\n    };\n    // Update last song in user profile\n    const updateLastSong = async (songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"users\").update({\n                last_song_file_id: parseInt(songId)\n            }).eq(\"id\", user.id);\n            if (error) throw error;\n        } catch (error) {\n            console.error(\"Error updating last song:\", error);\n        }\n    };\n    // Record listening history with proper time tracking\n    const recordListeningHistory = async (songId)=>{\n        if (!user) return;\n        // If there's a previous song playing, record its listening time\n        if (currentSongRef.current && currentSongStartTime) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: user.id,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history:\", error);\n                    } else {\n                        console.log(\"✅ History updated: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording previous song history:\", error);\n                }\n            }\n        }\n        // Set new song as current\n        currentSongRef.current = songId;\n        setCurrentSongStartTime(new Date());\n        // Update last song in user profile\n        await updateLastSong(songId);\n        try {\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"increment_song_views\", {\n                song_file_id: parseInt(songId)\n            });\n        } catch (error) {\n            console.error(\"Error incrementing song views:\", error);\n        }\n    };\n    // Stop current song tracking (when player is closed)\n    const stopCurrentSongTracking = async ()=>{\n        if (currentSongRef.current && currentSongStartTime && user) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: user.id,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history on stop:\", error);\n                    } else {\n                        console.log(\"\\uD83D\\uDED1 History updated on stop: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording final song history:\", error);\n                }\n            }\n        }\n        currentSongRef.current = null;\n        setCurrentSongStartTime(null);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const loadData = async ()=>{\n            if (!user) {\n                // Reset data when user logs out\n                setSongs([]);\n                setPlaylists([]);\n                setLikedSongs(new Set());\n                setLastPlayedSong(null);\n                setLoading(false);\n                return;\n            }\n            try {\n                setLoading(true);\n                await Promise.all([\n                    fetchSongs(),\n                    fetchPlaylists()\n                ]);\n            } catch (error) {\n                console.error(\"Error loading data:\", error);\n            } finally{\n                setLoading(false);\n            }\n        };\n        loadData();\n    }, [\n        user\n    ]);\n    return {\n        songs,\n        playlists,\n        likedSongs: songs.filter((song)=>song.isLiked),\n        lastPlayedSong,\n        loading,\n        toggleLike,\n        createPlaylist,\n        deletePlaylist,\n        renamePlaylist,\n        addSongToPlaylist,\n        removeSongFromPlaylist,\n        recordListeningHistory,\n        stopCurrentSongTracking,\n        refreshData: ()=>{\n            fetchSongs();\n            fetchPlaylists();\n        },\n        getPersonalizedSongs,\n        getSmartPersonalizedSongs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1EO0FBRXNCO0FBR2xFLFNBQVNJLGdCQUFnQkMsSUFBaUI7SUFDL0MsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdQLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDUSxXQUFXQyxhQUFhLEdBQUdULCtDQUFRQSxDQUFhLEVBQUU7SUFDekQsTUFBTSxDQUFDVSxZQUFZQyxjQUFjLEdBQUdYLCtDQUFRQSxDQUFjLElBQUlZO0lBQzlELE1BQU0sQ0FBQ0MsZ0JBQWdCQyxrQkFBa0IsR0FBR2QsK0NBQVFBLENBQWM7SUFDbEUsTUFBTSxDQUFDZSxTQUFTQyxXQUFXLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNpQixzQkFBc0JDLHdCQUF3QixHQUFHbEIsK0NBQVFBLENBQWM7SUFDOUUsTUFBTW1CLGlCQUFpQmpCLDZDQUFNQSxDQUFnQjtJQUU3QyxzRUFBc0U7SUFDdEUsTUFBTWtCLDRCQUE0QixPQUNoQ0MsUUFDQUMsc0JBQ0FDO1FBRUEsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFDWkQsUUFBUUMsR0FBRyxDQUFDLGlEQUF1Q0gscUJBQXFCSSxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUk7WUFFdkYsSUFBSU4scUJBQXFCTyxNQUFNLEtBQUssR0FBRztnQkFDckNMLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixPQUFPLEVBQUU7WUFDWDtZQUVBLCtDQUErQztZQUMvQyxNQUFNSyxnQkFBZ0IsSUFBSWxCO1lBQzFCLE1BQU1tQixtQkFBbUIsSUFBSW5CO1lBRTdCVSxxQkFBcUJVLE9BQU8sQ0FBQ0MsQ0FBQUE7b0JBQzNCQTtpQkFBQUEsYUFBQUEsS0FBS0MsSUFBSSxjQUFURCxpQ0FBQUEsV0FBV0QsT0FBTyxDQUFDRyxDQUFBQSxNQUFPTCxjQUFjTSxHQUFHLENBQUNELElBQUlFLFdBQVc7Z0JBQzNETixpQkFBaUJLLEdBQUcsQ0FBQ0gsS0FBS0ssTUFBTSxDQUFDRCxXQUFXO1lBQzlDO1lBRUFiLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBdUJjLE1BQU1DLElBQUksQ0FBQ1Y7WUFDOUNOLFFBQVFDLEdBQUcsQ0FBQyxtQ0FBeUJjLE1BQU1DLElBQUksQ0FBQ1Q7WUFFaEQsZ0NBQWdDO1lBQ2hDLE1BQU0sRUFBRVUsTUFBTUMsU0FBUyxFQUFFQyxPQUFPQyxVQUFVLEVBQUUsR0FBRyxNQUFNekMsbURBQVFBLENBQzFEcUMsSUFBSSxDQUFDLFNBQ0xLLE1BQU0sQ0FBQztZQUVWLElBQUlELFlBQVk7Z0JBQ2RwQixRQUFRbUIsS0FBSyxDQUFDLHFEQUFxREM7Z0JBQ25FLE9BQU8sRUFBRTtZQUNYO1lBRUEsSUFBSSxDQUFDRixhQUFhQSxVQUFVYixNQUFNLEtBQUssR0FBRztnQkFDeENMLFFBQVFzQixJQUFJLENBQUM7Z0JBQ2IsT0FBTyxFQUFFO1lBQ1g7WUFFQSx5QkFBeUI7WUFDekIsTUFBTSxFQUFFTCxNQUFNTSxTQUFTLEVBQUUsR0FBRyxNQUFNNUMsbURBQVFBLENBQ3ZDcUMsSUFBSSxDQUFDLGVBQ0xLLE1BQU0sQ0FBQyxXQUNQRyxFQUFFLENBQUMsV0FBVzNCO1lBRWpCLE1BQU00QixpQkFBaUIsSUFBSXJDO1lBQzNCLElBQUltQyxXQUFXO2dCQUNiQSxVQUFVZixPQUFPLENBQUNrQixDQUFBQSxPQUFRRCxlQUFlYixHQUFHLENBQUNjLEtBQUtDLE9BQU87WUFDM0Q7WUFFQSx3REFBd0Q7WUFDeEQsTUFBTUMsaUJBQWlCVixVQUFVVyxNQUFNLENBQUMsQ0FBQ3BCO2dCQUN2QyxPQUFPLENBQUNWLGFBQWErQixHQUFHLENBQUNyQixLQUFLc0IsT0FBTyxDQUFDQyxRQUFRO1lBQ2hEO1lBRUFoQyxRQUFRQyxHQUFHLENBQUMsMkRBQXVFLE9BQXRCMkIsZUFBZXZCLE1BQU07WUFFbEYsSUFBSXVCLGVBQWV2QixNQUFNLEtBQUssR0FBRztnQkFDL0JMLFFBQVFzQixJQUFJLENBQUM7Z0JBQ2IsT0FBTyxFQUFFO1lBQ1g7WUFFQSxvREFBb0Q7WUFDcEQsTUFBTVcsY0FBY0wsZUFBZTFCLEdBQUcsQ0FBQyxDQUFDTztvQkFJckJBO2dCQUhqQixJQUFJeUIsUUFBUTtnQkFFWixrREFBa0Q7Z0JBQ2xELE1BQU1DLFdBQVcxQixFQUFBQSxhQUFBQSxLQUFLQyxJQUFJLGNBQVRELGlDQUFBQSxXQUFXUCxHQUFHLENBQUNTLENBQUFBLE1BQU9BLElBQUlFLFdBQVcsUUFBTyxFQUFFO2dCQUMvRCxNQUFNdUIsZUFBZUQsU0FBU04sTUFBTSxDQUFDbEIsQ0FBQUEsTUFBT0wsY0FBY3dCLEdBQUcsQ0FBQ25CO2dCQUM5RHVCLFNBQVNFLGFBQWEvQixNQUFNLEdBQUcsSUFBSSxpQ0FBaUM7Z0JBRXBFLHFEQUFxRDtnQkFDckQsSUFBSUUsaUJBQWlCdUIsR0FBRyxDQUFDckIsS0FBS0ssTUFBTSxDQUFDRCxXQUFXLEtBQUs7b0JBQ25EcUIsU0FBUyxJQUFJLG9DQUFvQztnQkFDbkQ7Z0JBRUEsbURBQW1EO2dCQUNuRCxNQUFNRyxvQkFBb0J2QyxxQkFBcUJJLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRW1DLFFBQVE7Z0JBQ2xFLElBQUlELGtCQUFrQkUsUUFBUSxDQUFDOUIsS0FBSzZCLFFBQVEsR0FBRztvQkFDN0NKLFNBQVM7Z0JBQ1g7Z0JBRUEscUNBQXFDO2dCQUNyQ0EsU0FBU00sS0FBS3ZDLEdBQUcsQ0FBQyxJQUFLUSxDQUFBQSxLQUFLZ0MsS0FBSyxJQUFJLE1BQU07Z0JBQzNDUCxTQUFTTSxLQUFLdkMsR0FBRyxDQUFDLElBQUtRLENBQUFBLEtBQUtpQyxLQUFLLElBQUksTUFBTTtnQkFFM0Msd0JBQXdCO2dCQUN4QixJQUFJakIsZUFBZUssR0FBRyxDQUFDckIsS0FBS3NCLE9BQU8sR0FBRztvQkFDcENHLFNBQVM7Z0JBQ1g7Z0JBRUEsMkNBQTJDO2dCQUMzQ0EsU0FBU00sS0FBS0csTUFBTSxLQUFLO2dCQUV6QixPQUFPO29CQUNMbEMsTUFBTW1DLG9CQUFvQm5DLE1BQU1nQixlQUFlSyxHQUFHLENBQUNyQixLQUFLc0IsT0FBTztvQkFDL0RHO2dCQUNGO1lBQ0Y7WUFFQSwrQ0FBK0M7WUFDL0MsTUFBTVcsa0JBQWtCWixZQUNyQmEsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVkLEtBQUssR0FBR2EsRUFBRWIsS0FBSyxFQUNoQ2UsS0FBSyxDQUFDLEdBQUcsSUFBSSw2QkFBNkI7YUFDMUMvQyxHQUFHLENBQUNnRCxDQUFBQSxRQUFTQSxNQUFNekMsSUFBSTtZQUUxQlQsUUFBUUMsR0FBRyxDQUFDLG1FQUNWNEMsZ0JBQWdCSSxLQUFLLENBQUMsR0FBRyxHQUFHL0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLLEdBQWdCQSxPQUFiQSxFQUFFQyxJQUFJLEVBQUMsUUFBZSxPQUFURCxFQUFFVyxNQUFNO1lBRS9ELE9BQU8rQjtRQUVULEVBQUUsT0FBTzFCLE9BQU87WUFDZG5CLFFBQVFtQixLQUFLLENBQUMseUNBQXlDQTtZQUN2RCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsMENBQTBDO0lBQzFDLE1BQU15QixzQkFBc0IsU0FBQ087WUFBc0JDLDJFQUFtQjtlQUFpQjtZQUNyRnJCLFNBQVNvQixPQUFPcEIsT0FBTztZQUN2QnNCLFFBQVFGLE9BQU9FLE1BQU07WUFDckJqRCxNQUFNK0MsT0FBTy9DLElBQUk7WUFDakJVLFFBQVFxQyxPQUFPckMsTUFBTTtZQUNyQndCLFVBQVVhLE9BQU9iLFFBQVE7WUFDekI1QixNQUFNeUMsT0FBT3pDLElBQUk7WUFDakJnQyxPQUFPUyxPQUFPVCxLQUFLO1lBQ25CRCxPQUFPVSxPQUFPVixLQUFLO1lBQ25CYSxJQUFJSCxPQUFPcEIsT0FBTyxDQUFDQyxRQUFRO1lBQzNCdUIsT0FBTyxvQ0FBa0VKLE9BQTlCQSxPQUFPRSxNQUFNLEVBQUMsa0JBQThCLE9BQWRGLE9BQU9FLE1BQU0sRUFBQztZQUN2RkQ7UUFDRjs7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTUksYUFBYTtRQUNqQixJQUFJLENBQUMzRSxNQUFNO1lBQ1RFLFNBQVMsRUFBRTtZQUNYO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsTUFBTSxFQUFFa0MsTUFBTUMsU0FBUyxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNeEMsbURBQVFBLENBQzlDcUMsSUFBSSxDQUFDLFNBQ0xLLE1BQU0sQ0FBQyxLQUNQb0MsS0FBSyxDQUFDLFNBQVM7Z0JBQUVDLFdBQVc7WUFBTTtZQUVyQyxJQUFJdkMsT0FBTyxNQUFNQTtZQUVqQixJQUFJTSxpQkFBaUIsSUFBSXJDO1lBRXpCLE1BQU0sRUFBRTZCLE1BQU1NLFNBQVMsRUFBRSxHQUFHLE1BQU01QyxtREFBUUEsQ0FDdkNxQyxJQUFJLENBQUMsZUFDTEssTUFBTSxDQUFDLFdBQ1BHLEVBQUUsQ0FBQyxXQUFXM0MsS0FBS3lFLEVBQUU7WUFFeEIsSUFBSS9CLFdBQVc7Z0JBQ2JFLGlCQUFpQixJQUFJckMsSUFBSW1DLFVBQVVyQixHQUFHLENBQUN3QixDQUFBQSxPQUFRQSxLQUFLQyxPQUFPO2dCQUMzRHhDLGNBQWNzQztZQUNoQjtZQUVBLE1BQU1rQyxpQkFBaUJ6QyxDQUFBQSxzQkFBQUEsZ0NBQUFBLFVBQVdoQixHQUFHLENBQUNPLENBQUFBLE9BQ3BDbUMsb0JBQW9CbkMsTUFBTWdCLGVBQWVLLEdBQUcsQ0FBQ3JCLEtBQUtzQixPQUFPLFFBQ3RELEVBQUU7WUFFUCxNQUFNNkIsY0FBYzttQkFBSUQ7YUFBZSxDQUFDYixJQUFJLENBQUMsQ0FBQ0MsR0FBR0M7Z0JBQy9DLE1BQU1hLFNBQVNkLEVBQUVMLEtBQUssR0FBR0ssRUFBRU4sS0FBSztnQkFDaEMsTUFBTXFCLFNBQVNkLEVBQUVOLEtBQUssR0FBR00sRUFBRVAsS0FBSztnQkFDaEMsT0FBT3FCLFNBQVNEO1lBQ2xCO1lBRUE5RSxTQUFTNkU7WUFFVCxNQUFNLEVBQUUzQyxNQUFNOEMsUUFBUSxFQUFFLEdBQUcsTUFBTXBGLG1EQUFRQSxDQUN0Q3FDLElBQUksQ0FBQyxTQUNMSyxNQUFNLENBQUMscUJBQ1BHLEVBQUUsQ0FBQyxNQUFNM0MsS0FBS3lFLEVBQUUsRUFDaEJVLE1BQU07WUFFVCxJQUFJRCxxQkFBQUEsK0JBQUFBLFNBQVVFLGlCQUFpQixFQUFFO2dCQUMvQixNQUFNQyxXQUFXUCxlQUFlUSxJQUFJLENBQUMxRCxDQUFBQSxPQUFRQSxLQUFLc0IsT0FBTyxLQUFLZ0MsU0FBU0UsaUJBQWlCO2dCQUN4RixJQUFJQyxVQUFVO29CQUNaNUUsa0JBQWtCNEU7Z0JBQ3BCO1lBQ0Y7UUFDRixFQUFFLE9BQU8vQyxPQUFPO1lBQ2RuQixRQUFRbUIsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkNwQyxTQUFTLEVBQUUsRUFBRSwyQkFBMkI7O1FBQzFDO0lBQ0Y7SUFFQSxrRUFBa0U7SUFDbEUsTUFBTXFGLHVCQUF1QixPQUFPdkUsUUFBZ0J3RSxhQUFtQkM7UUFDckUsSUFBSTtZQUNGdEUsUUFBUUMsR0FBRyxDQUFDLGlEQUF1Q29FLFlBQVlqRSxJQUFJO1lBQ25FSixRQUFRQyxHQUFHLENBQUMsc0NBQTRCcUUsQ0FBQUEsMEJBQUFBLG9DQUFBQSxjQUFlQyxJQUFJLEtBQUk7WUFFL0QsbUNBQW1DO1lBQ25DLE1BQU0sRUFBRXRELE1BQU1DLFNBQVMsRUFBRUMsT0FBT0MsVUFBVSxFQUFFLEdBQUcsTUFBTXpDLG1EQUFRQSxDQUMxRHFDLElBQUksQ0FBQyxTQUNMSyxNQUFNLENBQUM7WUFFVixJQUFJRCxZQUFZO2dCQUNkcEIsUUFBUW1CLEtBQUssQ0FBQywrQ0FBK0NDO2dCQUM3RCxPQUFPLEVBQUU7WUFDWDtZQUVBLElBQUksQ0FBQ0YsYUFBYUEsVUFBVWIsTUFBTSxLQUFLLEdBQUc7Z0JBQ3hDTCxRQUFRc0IsSUFBSSxDQUFDO2dCQUNiLE9BQU8sRUFBRTtZQUNYO1lBRUEsb0NBQW9DO1lBQ3BDLE1BQU0sRUFBRUwsTUFBTXVELFdBQVcsRUFBRXJELE9BQU9zRCxZQUFZLEVBQUUsR0FBRyxNQUFNOUYsbURBQVFBLENBQzlEcUMsSUFBSSxDQUFDLFdBQ0xLLE1BQU0sQ0FBQyw2QkFDUEcsRUFBRSxDQUFDLFdBQVczQjtZQUVqQixJQUFJNEUsY0FBYztnQkFDaEJ6RSxRQUFRbUIsS0FBSyxDQUFDLDZCQUE2QnNEO1lBQzdDO1lBRUEsTUFBTUMsYUFBYSxJQUFJQztZQUN2QixJQUFJSCxhQUFhO2dCQUNmQSxZQUFZaEUsT0FBTyxDQUFDb0UsQ0FBQUEsSUFBS0YsV0FBV0csR0FBRyxDQUFDRCxFQUFFakQsT0FBTyxFQUFFaUQsRUFBRUUsZ0JBQWdCLElBQUk7WUFDM0U7WUFFQSw0QkFBNEI7WUFDNUIsTUFBTSxFQUFFN0QsTUFBTU0sU0FBUyxFQUFFLEdBQUcsTUFBTTVDLG1EQUFRQSxDQUN2Q3FDLElBQUksQ0FBQyxlQUNMSyxNQUFNLENBQUMsV0FDUEcsRUFBRSxDQUFDLFdBQVczQjtZQUVqQixNQUFNNEIsaUJBQWlCLElBQUlyQztZQUMzQixJQUFJbUMsV0FBVztnQkFDYkEsVUFBVWYsT0FBTyxDQUFDa0IsQ0FBQUEsT0FBUUQsZUFBZWIsR0FBRyxDQUFDYyxLQUFLQyxPQUFPO1lBQzNEO1lBRUEsNEJBQTRCO1lBQzVCLE1BQU1DLGlCQUFpQlYsVUFBVVcsTUFBTSxDQUFDLENBQUNwQjtnQkFDdkMsdUJBQXVCO2dCQUN2QixJQUFJQSxLQUFLc0IsT0FBTyxLQUFLc0MsWUFBWXRDLE9BQU8sRUFBRTtvQkFDeEMsT0FBTztnQkFDVDtnQkFFQSxxQ0FBcUM7Z0JBQ3JDLElBQUl1QyxpQkFBaUJBLGNBQWN4QyxHQUFHLENBQUNyQixLQUFLc0IsT0FBTyxDQUFDQyxRQUFRLEtBQUs7b0JBQy9EaEMsUUFBUUMsR0FBRyxDQUFDLHlDQUErQ1EsT0FBaEJBLEtBQUtMLElBQUksRUFBQyxRQUFrQixPQUFaSyxLQUFLSyxNQUFNO29CQUN0RSxPQUFPO2dCQUNUO2dCQUVBLE9BQU87WUFDVDtZQUVBZCxRQUFRQyxHQUFHLENBQUMsaURBQTZELE9BQXRCMkIsZUFBZXZCLE1BQU07WUFFeEUsSUFBSXVCLGVBQWV2QixNQUFNLEtBQUssR0FBRztnQkFDL0JMLFFBQVFzQixJQUFJLENBQUM7Z0JBQ2IsT0FBTyxFQUFFO1lBQ1g7WUFFQSwwQkFBMEI7WUFDMUIsTUFBTVcsY0FBY0wsZUFBZTFCLEdBQUcsQ0FBQyxDQUFDTztvQkFJakJBO2dCQUhyQixJQUFJeUIsUUFBUTtnQkFFWixrQ0FBa0M7Z0JBQ2xDLE1BQU1FLGVBQWUzQixFQUFBQSxhQUFBQSxLQUFLQyxJQUFJLGNBQVRELGlDQUFBQSxXQUFXb0IsTUFBTSxDQUFDLENBQUNsQjt3QkFDdEMwRDs0QkFBQUEsb0JBQUFBLFlBQVkzRCxJQUFJLGNBQWhCMkQsd0NBQUFBLGtCQUFrQjlCLFFBQVEsQ0FBQzVCO3VCQUN4QixFQUFFO2dCQUNQdUIsU0FBU0UsYUFBYS9CLE1BQU0sR0FBRztnQkFFL0Isa0JBQWtCO2dCQUNsQixJQUFJSSxLQUFLSyxNQUFNLEtBQUt1RCxZQUFZdkQsTUFBTSxFQUFFO29CQUN0Q29CLFNBQVM7Z0JBQ1g7Z0JBRUEsb0JBQW9CO2dCQUNwQixJQUFJekIsS0FBSzZCLFFBQVEsS0FBSytCLFlBQVkvQixRQUFRLEVBQUU7b0JBQzFDSixTQUFTO2dCQUNYO2dCQUVBLDBCQUEwQjtnQkFDMUIsTUFBTTZDLGtCQUFrQkwsV0FBV00sR0FBRyxDQUFDdkUsS0FBS3NCLE9BQU8sS0FBSztnQkFDeERHLFNBQVNNLEtBQUt5QyxHQUFHLENBQUNGLGtCQUFrQixHQUFHLEtBQUssbUJBQW1CO2dCQUUvRCxxQ0FBcUM7Z0JBQ3JDN0MsU0FBU00sS0FBS3ZDLEdBQUcsQ0FBQyxJQUFLUSxDQUFBQSxLQUFLZ0MsS0FBSyxJQUFJLE1BQU07Z0JBQzNDUCxTQUFTTSxLQUFLdkMsR0FBRyxDQUFDLElBQUtRLENBQUFBLEtBQUtpQyxLQUFLLElBQUksTUFBTTtnQkFFM0Msb0JBQW9CO2dCQUNwQixJQUFJakIsZUFBZUssR0FBRyxDQUFDckIsS0FBS3NCLE9BQU8sR0FBRztvQkFDcENHLFNBQVM7Z0JBQ1g7Z0JBRUEsZ0RBQWdEO2dCQUNoREEsU0FBU00sS0FBS0csTUFBTSxLQUFLO2dCQUV6QixPQUFPO29CQUNMbEMsTUFBTW1DLG9CQUFvQm5DLE1BQU1nQixlQUFlSyxHQUFHLENBQUNyQixLQUFLc0IsT0FBTztvQkFDL0RHO2dCQUNGO1lBQ0Y7WUFFQSxrREFBa0Q7WUFDbEQsTUFBTVcsa0JBQWtCWixZQUNyQmEsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVkLEtBQUssR0FBR2EsRUFBRWIsS0FBSyxFQUNoQ2UsS0FBSyxDQUFDLEdBQUcsSUFBSSxrQ0FBa0M7YUFDL0MvQyxHQUFHLENBQUNnRCxDQUFBQSxRQUFTQSxNQUFNekMsSUFBSTtZQUUxQlQsUUFBUUMsR0FBRyxDQUFDLDhDQUFvQzRDLGdCQUFnQkksS0FBSyxDQUFDLEdBQUcsR0FBRy9DLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBSyxHQUFnQkEsT0FBYkEsRUFBRUMsSUFBSSxFQUFDLFFBQWUsT0FBVEQsRUFBRVcsTUFBTTtZQUM3R2QsUUFBUUMsR0FBRyxDQUFDLHVDQUE2QjJCLGVBQWV2QixNQUFNO1lBRTlELE9BQU93QztRQUVULEVBQUUsT0FBTzFCLE9BQU87WUFDZG5CLFFBQVFtQixLQUFLLENBQUMsb0NBQW9DQTtZQUNsRCxPQUFPLEVBQUU7UUFDWDtJQUNGO0lBRUEsdUJBQXVCO0lBQ3ZCLE1BQU0rRCxpQkFBaUI7UUFDckIsSUFBSSxDQUFDckcsTUFBTTtZQUNUSSxhQUFhLEVBQUU7WUFDZjtRQUNGO1FBRUEsSUFBSTtZQUNGLE1BQU0sRUFBRWdDLE1BQU1rRSxhQUFhLEVBQUVoRSxLQUFLLEVBQUUsR0FBRyxNQUFNeEMsbURBQVFBLENBQ2xEcUMsSUFBSSxDQUFDLGFBQ0xLLE1BQU0sQ0FBRSw4R0FPUkcsRUFBRSxDQUFDLFdBQVczQyxLQUFLeUUsRUFBRTtZQUV4QixJQUFJbkMsT0FBTyxNQUFNQTtZQUVqQixNQUFNaUUscUJBQWlDRCxDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVqRixHQUFHLENBQUNtRixDQUFBQTtvQkFDbENBLDBCQVFiQztnQkFSVCxNQUFNQSxnQkFBZ0JELEVBQUFBLDJCQUFBQSxTQUFTRSxjQUFjLGNBQXZCRiwrQ0FBQUEseUJBQXlCbkYsR0FBRyxDQUFDLENBQUNzRixLQUNsRDVDLG9CQUFvQjRDLEdBQUcxRyxLQUFLLEVBQUVJLFdBQVc0QyxHQUFHLENBQUMwRCxHQUFHMUcsS0FBSyxDQUFDaUQsT0FBTyxRQUMxRCxFQUFFO2dCQUVQLE9BQU87b0JBQ0x1QixJQUFJK0IsU0FBUy9CLEVBQUUsQ0FBQ3RCLFFBQVE7b0JBQ3hCNUIsTUFBTWlGLFNBQVNqRixJQUFJO29CQUNuQnFGLFdBQVdILGNBQWNqRixNQUFNO29CQUMvQmtELE9BQU8rQixFQUFBQSxrQkFBQUEsYUFBYSxDQUFDLEVBQUUsY0FBaEJBLHNDQUFBQSxnQkFBa0IvQixLQUFLLEtBQUk7b0JBQ2xDekUsT0FBT3dHO2dCQUNUO1lBQ0YsT0FBTSxFQUFFO1lBRVJyRyxhQUFhbUc7UUFDZixFQUFFLE9BQU9qRSxPQUFPO1lBQ2RuQixRQUFRbUIsS0FBSyxDQUFDLDZCQUE2QkE7UUFDN0M7SUFDRjtJQUVBLG1CQUFtQjtJQUNuQixNQUFNdUUsYUFBYSxPQUFPQztRQUMxQixJQUFJLENBQUM5RyxNQUFNO1FBRVgsTUFBTStHLGFBQWFDLFNBQVNGO1FBQzVCLE1BQU1HLG1CQUFtQjVHLFdBQVc0QyxHQUFHLENBQUM4RDtRQUV4QyxJQUFJO1lBQ0YsSUFBSUUsa0JBQWtCO2dCQUNwQiwwQkFBMEI7Z0JBQzFCLE1BQU0sRUFBRTNFLEtBQUssRUFBRSxHQUFHLE1BQU14QyxtREFBUUEsQ0FDN0JxQyxJQUFJLENBQUMsZUFDTCtFLE1BQU0sR0FDTnZFLEVBQUUsQ0FBQyxXQUFXM0MsS0FBS3lFLEVBQUUsRUFDckI5QixFQUFFLENBQUMsV0FBV29FO2dCQUVqQixJQUFJekUsT0FBTyxNQUFNQTtnQkFFakIsa0JBQWtCO2dCQUNsQixNQUFNeEMsbURBQVFBLENBQUNxSCxHQUFHLENBQUMsd0JBQXdCO29CQUFFQyxjQUFjTDtnQkFBVztnQkFFdEV6RyxjQUFjK0csQ0FBQUE7b0JBQ1osTUFBTUMsU0FBUyxJQUFJL0csSUFBSThHO29CQUN2QkMsT0FBT0osTUFBTSxDQUFDSDtvQkFDZCxPQUFPTztnQkFDVDtZQUNGLE9BQU87Z0JBQ0wscUJBQXFCO2dCQUNyQixNQUFNLEVBQUVoRixLQUFLLEVBQUUsR0FBRyxNQUFNeEMsbURBQVFBLENBQzdCcUMsSUFBSSxDQUFDLGVBQ0xvRixNQUFNLENBQUM7b0JBQ05DLFNBQVN4SCxLQUFLeUUsRUFBRTtvQkFDaEIzQixTQUFTaUU7Z0JBQ1g7Z0JBRUYsSUFBSXpFLE9BQU8sTUFBTUE7Z0JBRWpCLGtCQUFrQjtnQkFDbEIsTUFBTXhDLG1EQUFRQSxDQUFDcUgsR0FBRyxDQUFDLHdCQUF3QjtvQkFBRUMsY0FBY0w7Z0JBQVc7Z0JBRXRFekcsY0FBYytHLENBQUFBLE9BQVEsSUFBSTlHLElBQUk4RyxNQUFNdEYsR0FBRyxDQUFDZ0Y7WUFDMUM7WUFFQSxxQkFBcUI7WUFDckIscUJBQXFCO1lBQ3pCN0csU0FBU3VILENBQUFBLFlBQ1BBLFVBQVVwRyxHQUFHLENBQUNPLENBQUFBLE9BQ1pBLEtBQUs2QyxFQUFFLEtBQUtxQyxTQUNSO3dCQUNFLEdBQUdsRixJQUFJO3dCQUNQMkMsU0FBUyxDQUFDMEM7d0JBQ1ZyRCxPQUFPaEMsS0FBS2dDLEtBQUssR0FBSXFELENBQUFBLG1CQUFtQixDQUFDLElBQUk7b0JBQy9DLElBQ0FyRjtZQUtKLHlCQUF5QjtZQUN6QnhCLGFBQWFzSCxDQUFBQSxnQkFDWEEsY0FBY3JHLEdBQUcsQ0FBQ21GLENBQUFBLFdBQWE7d0JBQzdCLEdBQUdBLFFBQVE7d0JBQ1h2RyxPQUFPdUcsU0FBU3ZHLEtBQUssQ0FBQ29CLEdBQUcsQ0FBQ08sQ0FBQUEsT0FDeEJBLEtBQUs2QyxFQUFFLEtBQUtxQyxTQUNSO2dDQUNFLEdBQUdsRixJQUFJO2dDQUNQMkMsU0FBUyxDQUFDMEM7Z0NBQ1ZyRCxPQUFPaEMsS0FBS2dDLEtBQUssR0FBSXFELENBQUFBLG1CQUFtQixDQUFDLElBQUk7NEJBQy9DLElBQ0FyRjtvQkFFUjtRQUVKLEVBQUUsT0FBT1UsT0FBTztZQUNkbkIsUUFBUW1CLEtBQUssQ0FBQyx3QkFBd0JBO1FBQ3hDO0lBQ0Y7SUFHRSxrQkFBa0I7SUFDbEIsTUFBTXFGLGlCQUFpQixPQUFPcEc7UUFDNUIsSUFBSSxDQUFDdkIsTUFBTTtRQUVYLElBQUk7WUFDRixNQUFNLEVBQUVvQyxJQUFJLEVBQUVFLEtBQUssRUFBRSxHQUFHLE1BQU14QyxtREFBUUEsQ0FDbkNxQyxJQUFJLENBQUMsYUFDTG9GLE1BQU0sQ0FBQztnQkFDTkMsU0FBU3hILEtBQUt5RSxFQUFFO2dCQUNoQmxEO1lBQ0YsR0FDQ2lCLE1BQU0sR0FDTjJDLE1BQU07WUFFVCxJQUFJN0MsT0FBTyxNQUFNQTtZQUVqQixNQUFNc0YsY0FBd0I7Z0JBQzVCbkQsSUFBSXJDLEtBQUtxQyxFQUFFLENBQUN0QixRQUFRO2dCQUNwQjVCLE1BQU1hLEtBQUtiLElBQUk7Z0JBQ2ZxRixXQUFXO2dCQUNYbEMsT0FBTztnQkFDUHpFLE9BQU8sRUFBRTtZQUNYO1lBRUFHLGFBQWFpSCxDQUFBQSxPQUFRO3VCQUFJQTtvQkFBTU87aUJBQVk7UUFDN0MsRUFBRSxPQUFPdEYsT0FBTztZQUNkbkIsUUFBUW1CLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzVDO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTXVGLGlCQUFpQixPQUFPQztRQUM1QixJQUFJLENBQUM5SCxNQUFNO1FBRVgsSUFBSTtZQUNGLE1BQU0sRUFBRXNDLEtBQUssRUFBRSxHQUFHLE1BQU14QyxtREFBUUEsQ0FDN0JxQyxJQUFJLENBQUMsYUFDTCtFLE1BQU0sR0FDTnZFLEVBQUUsQ0FBQyxNQUFNcUUsU0FBU2MsYUFDbEJuRixFQUFFLENBQUMsV0FBVzNDLEtBQUt5RSxFQUFFO1lBRXhCLElBQUluQyxPQUFPLE1BQU1BO1lBRWpCbEMsYUFBYWlILENBQUFBLE9BQVFBLEtBQUtyRSxNQUFNLENBQUN3RCxDQUFBQSxXQUFZQSxTQUFTL0IsRUFBRSxLQUFLcUQ7UUFDL0QsRUFBRSxPQUFPeEYsT0FBTztZQUNkbkIsUUFBUW1CLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzVDO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTXlGLGlCQUFpQixPQUFPRCxZQUFvQkU7UUFDaEQsSUFBSSxDQUFDaEksTUFBTTtRQUVYLElBQUk7WUFDRixNQUFNLEVBQUVzQyxLQUFLLEVBQUUsR0FBRyxNQUFNeEMsbURBQVFBLENBQzdCcUMsSUFBSSxDQUFDLGFBQ0w4RixNQUFNLENBQUM7Z0JBQUUxRyxNQUFNeUc7WUFBUSxHQUN2QnJGLEVBQUUsQ0FBQyxNQUFNcUUsU0FBU2MsYUFDbEJuRixFQUFFLENBQUMsV0FBVzNDLEtBQUt5RSxFQUFFO1lBRXhCLElBQUluQyxPQUFPLE1BQU1BO1lBRWpCbEMsYUFBYWlILENBQUFBLE9BQ1hBLEtBQUtoRyxHQUFHLENBQUNtRixDQUFBQSxXQUNQQSxTQUFTL0IsRUFBRSxLQUFLcUQsYUFDWjt3QkFBRSxHQUFHdEIsUUFBUTt3QkFBRWpGLE1BQU15RztvQkFBUSxJQUM3QnhCO1FBR1YsRUFBRSxPQUFPbEUsT0FBTztZQUNkbkIsUUFBUW1CLEtBQUssQ0FBQyw0QkFBNEJBO1FBQzVDO0lBQ0Y7SUFFQSx1QkFBdUI7SUFDdkIsTUFBTTRGLG9CQUFvQixPQUFPSixZQUFvQmxHO1FBQ25ELElBQUksQ0FBQzVCLE1BQU07UUFFWCxJQUFJO1lBQ0YsTUFBTSxFQUFFc0MsS0FBSyxFQUFFLEdBQUcsTUFBTXhDLG1EQUFRQSxDQUM3QnFDLElBQUksQ0FBQyxrQkFDTG9GLE1BQU0sQ0FBQztnQkFDTlksYUFBYW5CLFNBQVNjO2dCQUN0QmhGLFNBQVNsQixLQUFLc0IsT0FBTztZQUN2QjtZQUVGLElBQUlaLE9BQU8sTUFBTUE7WUFFakJsQyxhQUFhaUgsQ0FBQUEsT0FDWEEsS0FBS2hHLEdBQUcsQ0FBQ21GLENBQUFBO29CQUNQLElBQUlBLFNBQVMvQixFQUFFLEtBQUtxRCxZQUFZO3dCQUM5QixNQUFNTSxhQUFhNUIsU0FBU3ZHLEtBQUssQ0FBQ29JLElBQUksQ0FBQy9HLENBQUFBLElBQUtBLEVBQUVtRCxFQUFFLEtBQUs3QyxLQUFLNkMsRUFBRTt3QkFDNUQsSUFBSSxDQUFDMkQsWUFBWTtnQ0FNTkU7NEJBTFQsTUFBTUEsZUFBZTttQ0FBSTlCLFNBQVN2RyxLQUFLO2dDQUFFMkI7NkJBQUs7NEJBQzlDLE9BQU87Z0NBQ0wsR0FBRzRFLFFBQVE7Z0NBQ1h2RyxPQUFPcUk7Z0NBQ1AxQixXQUFXMEIsYUFBYTlHLE1BQU07Z0NBQzlCa0QsT0FBTzRELEVBQUFBLGlCQUFBQSxZQUFZLENBQUMsRUFBRSxjQUFmQSxxQ0FBQUEsZUFBaUI1RCxLQUFLLEtBQUk4QixTQUFTOUIsS0FBSzs0QkFDakQ7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsT0FBTzhCO2dCQUNUO1FBRUosRUFBRSxPQUFPbEUsT0FBTztZQUNkbkIsUUFBUW1CLEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2xEO0lBQ0Y7SUFFQSw0QkFBNEI7SUFDNUIsTUFBTWlHLHlCQUF5QixPQUFPVCxZQUFvQmhCO1FBQ3hELElBQUksQ0FBQzlHLE1BQU07UUFFWCxJQUFJO1lBQ0YsTUFBTSxFQUFFc0MsS0FBSyxFQUFFLEdBQUcsTUFBTXhDLG1EQUFRQSxDQUM3QnFDLElBQUksQ0FBQyxrQkFDTCtFLE1BQU0sR0FDTnZFLEVBQUUsQ0FBQyxlQUFlcUUsU0FBU2MsYUFDM0JuRixFQUFFLENBQUMsV0FBV3FFLFNBQVNGO1lBRTFCLElBQUl4RSxPQUFPLE1BQU1BO1lBRWpCbEMsYUFBYWlILENBQUFBLE9BQ1hBLEtBQUtoRyxHQUFHLENBQUNtRixDQUFBQTtvQkFDUCxJQUFJQSxTQUFTL0IsRUFBRSxLQUFLcUQsWUFBWTs0QkFNckJRO3dCQUxULE1BQU1BLGVBQWU5QixTQUFTdkcsS0FBSyxDQUFDK0MsTUFBTSxDQUFDcEIsQ0FBQUEsT0FBUUEsS0FBSzZDLEVBQUUsS0FBS3FDO3dCQUMvRCxPQUFPOzRCQUNMLEdBQUdOLFFBQVE7NEJBQ1h2RyxPQUFPcUk7NEJBQ1AxQixXQUFXMEIsYUFBYTlHLE1BQU07NEJBQzlCa0QsT0FBTzRELEVBQUFBLGlCQUFBQSxZQUFZLENBQUMsRUFBRSxjQUFmQSxxQ0FBQUEsZUFBaUI1RCxLQUFLLEtBQUk7d0JBQ25DO29CQUNGO29CQUNBLE9BQU84QjtnQkFDVDtRQUVKLEVBQUUsT0FBT2xFLE9BQU87WUFDZG5CLFFBQVFtQixLQUFLLENBQUMsc0NBQXNDQTtRQUN0RDtJQUNGO0lBRUEsbUNBQW1DO0lBQ25DLE1BQU1rRyxpQkFBaUIsT0FBTzFCO1FBQzVCLElBQUksQ0FBQzlHLE1BQU07UUFFWCxJQUFJO1lBQ0YsTUFBTSxFQUFFc0MsS0FBSyxFQUFFLEdBQUcsTUFBTXhDLG1EQUFRQSxDQUM3QnFDLElBQUksQ0FBQyxTQUNMOEYsTUFBTSxDQUFDO2dCQUFFN0MsbUJBQW1CNEIsU0FBU0Y7WUFBUSxHQUM3Q25FLEVBQUUsQ0FBQyxNQUFNM0MsS0FBS3lFLEVBQUU7WUFFbkIsSUFBSW5DLE9BQU8sTUFBTUE7UUFDbkIsRUFBRSxPQUFPQSxPQUFPO1lBQ2RuQixRQUFRbUIsS0FBSyxDQUFDLDZCQUE2QkE7UUFDN0M7SUFDRjtJQUVBLHFEQUFxRDtJQUNyRCxNQUFNbUcseUJBQXlCLE9BQU8zQjtRQUNwQyxJQUFJLENBQUM5RyxNQUFNO1FBRVgsZ0VBQWdFO1FBQzlELElBQUljLGVBQWU0SCxPQUFPLElBQUk5SCxzQkFBc0I7WUFDdEQsTUFBTStILFVBQVUsSUFBSUM7WUFDcEIsTUFBTUMsa0JBQWtCLENBQUNGLFFBQVFHLE9BQU8sS0FBS2xJLHFCQUFxQmtJLE9BQU8sRUFBQyxJQUFNLFFBQU8sRUFBQztZQUV4RixJQUFJRCxrQkFBa0IsS0FBSztnQkFDekIsSUFBSTtvQkFDRixNQUFNRSxVQUFVcEYsS0FBS3FGLEtBQUssQ0FBQ0gsa0JBQWtCLE9BQU87b0JBQ3BELE1BQU0sRUFBRXZHLEtBQUssRUFBRSxHQUFHLE1BQU14QyxtREFBUUEsQ0FBQ3FILEdBQUcsQ0FBQywwQkFBMEI7d0JBQzdEOEIsV0FBV2pKLEtBQUt5RSxFQUFFO3dCQUNsQjJDLGNBQWNKLFNBQVNsRyxlQUFlNEgsT0FBTzt3QkFDN0NLLFNBQVNBO29CQUNYO29CQUVBLElBQUl6RyxPQUFPO3dCQUNUbkIsUUFBUW1CLEtBQUssQ0FBQyxtQ0FBbUNBO29CQUNuRCxPQUFPO3dCQUNMbkIsUUFBUUMsR0FBRyxDQUFDLHVCQUFnRE4sT0FBekJpSSxTQUFRLG1CQUF3QyxPQUF2QmpJLGVBQWU0SCxPQUFPO29CQUNwRjtnQkFDRixFQUFFLE9BQU9wRyxPQUFPO29CQUNkbkIsUUFBUW1CLEtBQUssQ0FBQywwQ0FBMENBO2dCQUMxRDtZQUNGO1FBQ0Y7UUFHRSwwQkFBMEI7UUFDMUJ4QixlQUFlNEgsT0FBTyxHQUFHNUI7UUFDekJqRyx3QkFBd0IsSUFBSStIO1FBRTVCLG1DQUFtQztRQUNuQyxNQUFNSixlQUFlMUI7UUFDekIsSUFBSTtZQUNGLE1BQU1oSCxtREFBUUEsQ0FBQ3FILEdBQUcsQ0FBQyx3QkFBd0I7Z0JBQUVDLGNBQWNKLFNBQVNGO1lBQVE7UUFDOUUsRUFBRSxPQUFPeEUsT0FBTztZQUNkbkIsUUFBUW1CLEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2xEO0lBRUU7SUFFQSxxREFBcUQ7SUFDckQsTUFBTTRHLDBCQUEwQjtRQUM5QixJQUFJcEksZUFBZTRILE9BQU8sSUFBSTlILHdCQUF3QlosTUFBTTtZQUMxRCxNQUFNMkksVUFBVSxJQUFJQztZQUNwQixNQUFNQyxrQkFBa0IsQ0FBQ0YsUUFBUUcsT0FBTyxLQUFLbEkscUJBQXFCa0ksT0FBTyxFQUFDLElBQU0sUUFBTyxFQUFDO1lBRXhGLElBQUlELGtCQUFrQixLQUFLO2dCQUMvQixJQUFJO29CQUNGLE1BQU1FLFVBQVVwRixLQUFLcUYsS0FBSyxDQUFDSCxrQkFBa0IsT0FBTztvQkFDcEQsTUFBTSxFQUFFdkcsS0FBSyxFQUFFLEdBQUcsTUFBTXhDLG1EQUFRQSxDQUFDcUgsR0FBRyxDQUFDLDBCQUEwQjt3QkFDN0Q4QixXQUFXakosS0FBS3lFLEVBQUU7d0JBQ2xCMkMsY0FBY0osU0FBU2xHLGVBQWU0SCxPQUFPO3dCQUM3Q0ssU0FBU0E7b0JBQ1g7b0JBRUEsSUFBSXpHLE9BQU87d0JBQ1RuQixRQUFRbUIsS0FBSyxDQUFDLDJDQUEyQ0E7b0JBQzNELE9BQU87d0JBQ0xuQixRQUFRQyxHQUFHLENBQUMsMENBQXlETixPQUF6QmlJLFNBQVEsbUJBQXdDLE9BQXZCakksZUFBZTRILE9BQU87b0JBQzdGO2dCQUNGLEVBQUUsT0FBT3BHLE9BQU87b0JBQ2RuQixRQUFRbUIsS0FBSyxDQUFDLHVDQUF1Q0E7Z0JBQ3ZEO1lBQ0Y7UUFFSTtRQUVBeEIsZUFBZTRILE9BQU8sR0FBRztRQUN6QjdILHdCQUF3QjtJQUMxQjtJQUVBakIsZ0RBQVNBLENBQUM7UUFDUixNQUFNdUosV0FBVztZQUNmLElBQUksQ0FBQ25KLE1BQU07Z0JBQ1QsZ0NBQWdDO2dCQUNoQ0UsU0FBUyxFQUFFO2dCQUNYRSxhQUFhLEVBQUU7Z0JBQ2ZFLGNBQWMsSUFBSUM7Z0JBQ2xCRSxrQkFBa0I7Z0JBQ2xCRSxXQUFXO2dCQUNYO1lBQ0Y7WUFFQSxJQUFJO2dCQUNGQSxXQUFXO2dCQUNYLE1BQU15SSxRQUFRQyxHQUFHLENBQUM7b0JBQUMxRTtvQkFBYzBCO2lCQUFpQjtZQUNwRCxFQUFFLE9BQU8vRCxPQUFPO2dCQUNkbkIsUUFBUW1CLEtBQUssQ0FBQyx1QkFBdUJBO1lBQ3ZDLFNBQVU7Z0JBQ1IzQixXQUFXO1lBQ2I7UUFDRjtRQUVBd0k7SUFDRixHQUFHO1FBQUNuSjtLQUFLO0lBRVQsT0FBTztRQUNMQztRQUNBRTtRQUNBRSxZQUFZSixNQUFNK0MsTUFBTSxDQUFDcEIsQ0FBQUEsT0FBUUEsS0FBSzJDLE9BQU87UUFDN0MvRDtRQUNBRTtRQUNBbUc7UUFDQWM7UUFDQUU7UUFDQUU7UUFDQUc7UUFDQUs7UUFDQUU7UUFDQVM7UUFDQUksYUFBYTtZQUNYM0U7WUFDQTBCO1FBQ0Y7UUFDQWQ7UUFDQXhFO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VTdXBhYmFzZURhdGEudHM/YWJmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVzZXIgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnXG5pbXBvcnQgeyBzdXBhYmFzZSwgRGF0YWJhc2VTb25nLCBEYXRhYmFzZVBsYXlsaXN0IH0gZnJvbSAnQC9saWIvc3VwYWJhc2UnXG5pbXBvcnQgeyBTb25nLCBQbGF5bGlzdCB9IGZyb20gJ0AvdHlwZXMnXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdXBhYmFzZURhdGEodXNlcjogVXNlciB8IG51bGwpIHtcbiAgY29uc3QgW3NvbmdzLCBzZXRTb25nc10gPSB1c2VTdGF0ZTxTb25nW10+KFtdKVxuICBjb25zdCBbcGxheWxpc3RzLCBzZXRQbGF5bGlzdHNdID0gdXNlU3RhdGU8UGxheWxpc3RbXT4oW10pXG4gIGNvbnN0IFtsaWtlZFNvbmdzLCBzZXRMaWtlZFNvbmdzXSA9IHVzZVN0YXRlPFNldDxudW1iZXI+PihuZXcgU2V0KCkpXG4gIGNvbnN0IFtsYXN0UGxheWVkU29uZywgc2V0TGFzdFBsYXllZFNvbmddID0gdXNlU3RhdGU8U29uZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpXG4gIGNvbnN0IFtjdXJyZW50U29uZ1N0YXJ0VGltZSwgc2V0Q3VycmVudFNvbmdTdGFydFRpbWVdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGN1cnJlbnRTb25nUmVmID0gdXNlUmVmPHN0cmluZyB8IG51bGw+KG51bGwpXG5cbiAgLy8gR2V0IHBlcnNvbmFsaXplZCBzb25ncyBiYXNlZCBvbiB1c2VyJ3MgYWN0dWFsIGxpc3RlbmluZyBwcmVmZXJlbmNlc1xuICBjb25zdCBnZXRTbWFydFBlcnNvbmFsaXplZFNvbmdzID0gYXN5bmMgKFxuICAgIHVzZXJJZDogc3RyaW5nLCBcbiAgICBsaXN0ZW5lZFNvbmdzSW5CYXRjaDogU29uZ1tdLCBcbiAgICBleGNsdWRlU29uZ3M6IFNldDxzdHJpbmc+XG4gICk6IFByb21pc2U8U29uZ1tdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCfwn6egIEZldGNoaW5nIHNtYXJ0IHBlcnNvbmFsaXplZCBzb25ncyBiYXNlZCBvbiBsaXN0ZW5pbmcgYmVoYXZpb3InKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn461IFNvbmdzIHVzZXIgYWN0dWFsbHkgbGlzdGVuZWQgdG86JywgbGlzdGVuZWRTb25nc0luQmF0Y2gubWFwKHMgPT4gcy5uYW1lKSk7XG4gICAgICBcbiAgICAgIGlmIChsaXN0ZW5lZFNvbmdzSW5CYXRjaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ+KaoO+4jyBObyBsaXN0ZW5lZCBzb25ncyBpbiBiYXRjaCwgZmFsbGluZyBiYWNrIHRvIHJlZ3VsYXIgcGVyc29uYWxpemF0aW9uJyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCB0YWdzIGFuZCBhcnRpc3RzIGZyb20gbGlzdGVuZWQgc29uZ3NcbiAgICAgIGNvbnN0IHByZWZlcnJlZFRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgIGNvbnN0IHByZWZlcnJlZEFydGlzdHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgIFxuICAgICAgbGlzdGVuZWRTb25nc0luQmF0Y2guZm9yRWFjaChzb25nID0+IHtcbiAgICAgICAgc29uZy50YWdzPy5mb3JFYWNoKHRhZyA9PiBwcmVmZXJyZWRUYWdzLmFkZCh0YWcudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICBwcmVmZXJyZWRBcnRpc3RzLmFkZChzb25nLmFydGlzdC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZygn8J+Pt++4jyBQcmVmZXJyZWQgdGFnczonLCBBcnJheS5mcm9tKHByZWZlcnJlZFRhZ3MpKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn46kIFByZWZlcnJlZCBhcnRpc3RzOicsIEFycmF5LmZyb20ocHJlZmVycmVkQXJ0aXN0cykpO1xuXG4gICAgICAvLyBGZXRjaCBhbGwgc29uZ3MgZnJvbSBkYXRhYmFzZVxuICAgICAgY29uc3QgeyBkYXRhOiBzb25nc0RhdGEsIGVycm9yOiBzb25nc0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc29uZ3MnKVxuICAgICAgICAuc2VsZWN0KCcqJyk7XG4gICAgICBcbiAgICAgIGlmIChzb25nc0Vycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBzb25ncyBmb3Igc21hcnQgcGVyc29uYWxpemF0aW9uOicsIHNvbmdzRXJyb3IpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghc29uZ3NEYXRhIHx8IHNvbmdzRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTm8gc29uZ3MgZm91bmQgaW4gZGF0YWJhc2UnKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgdXNlcidzIGxpa2VkIHNvbmdzXG4gICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgICBpZiAobGlrZWREYXRhKSB7XG4gICAgICAgIGxpa2VkRGF0YS5mb3JFYWNoKGl0ZW0gPT4gdXNlckxpa2VkU29uZ3MuYWRkKGl0ZW0uc29uZ19pZCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWx0ZXIgYW5kIHNjb3JlIHNvbmdzIGJhc2VkIG9uIGxpc3RlbmluZyBwcmVmZXJlbmNlc1xuICAgICAgY29uc3QgYXZhaWxhYmxlU29uZ3MgPSBzb25nc0RhdGEuZmlsdGVyKChzb25nKSA9PiB7XG4gICAgICAgIHJldHVybiAhZXhjbHVkZVNvbmdzLmhhcyhzb25nLmZpbGVfaWQudG9TdHJpbmcoKSk7XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coYPCfjrUgQXZhaWxhYmxlIHNvbmdzIGZvciBzbWFydCByZWNvbW1lbmRhdGlvbnM6ICR7YXZhaWxhYmxlU29uZ3MubGVuZ3RofWApO1xuXG4gICAgICBpZiAoYXZhaWxhYmxlU29uZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGF2YWlsYWJsZSBzb25ncyBhZnRlciBmaWx0ZXJpbmcnKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBTY29yZSBzb25ncyBiYXNlZCBvbiB1c2VyJ3MgbGlzdGVuaW5nIHByZWZlcmVuY2VzXG4gICAgICBjb25zdCBzY29yZWRTb25ncyA9IGF2YWlsYWJsZVNvbmdzLm1hcCgoc29uZykgPT4ge1xuICAgICAgICBsZXQgc2NvcmUgPSAwO1xuXG4gICAgICAgIC8vIEhpZ2ggcHJpb3JpdHk6IFRhZyBtYXRjaGluZyB3aXRoIGxpc3RlbmVkIHNvbmdzXG4gICAgICAgIGNvbnN0IHNvbmdUYWdzID0gc29uZy50YWdzPy5tYXAodGFnID0+IHRhZy50b0xvd2VyQ2FzZSgpKSB8fCBbXTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdUYWdzID0gc29uZ1RhZ3MuZmlsdGVyKHRhZyA9PiBwcmVmZXJyZWRUYWdzLmhhcyh0YWcpKTtcbiAgICAgICAgc2NvcmUgKz0gbWF0Y2hpbmdUYWdzLmxlbmd0aCAqIDI1OyAvLyBIaWdoZXIgd2VpZ2h0IGZvciB0YWcgbWF0Y2hpbmdcblxuICAgICAgICAvLyBIaWdoIHByaW9yaXR5OiBBcnRpc3QgbWF0Y2hpbmcgd2l0aCBsaXN0ZW5lZCBzb25nc1xuICAgICAgICBpZiAocHJlZmVycmVkQXJ0aXN0cy5oYXMoc29uZy5hcnRpc3QudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICBzY29yZSArPSAzMDsgLy8gSGlnaGVyIHdlaWdodCBmb3IgYXJ0aXN0IG1hdGNoaW5nXG4gICAgICAgIH1cblxuICAgICAgICAvLyBNZWRpdW0gcHJpb3JpdHk6IFNhbWUgbGFuZ3VhZ2UgYXMgbGlzdGVuZWQgc29uZ3NcbiAgICAgICAgY29uc3QgbGlzdGVuZWRMYW5ndWFnZXMgPSBsaXN0ZW5lZFNvbmdzSW5CYXRjaC5tYXAocyA9PiBzLmxhbmd1YWdlKTtcbiAgICAgICAgaWYgKGxpc3RlbmVkTGFuZ3VhZ2VzLmluY2x1ZGVzKHNvbmcubGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gMTU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb3dlciBwcmlvcml0eTogR2VuZXJhbCBwb3B1bGFyaXR5XG4gICAgICAgIHNjb3JlICs9IE1hdGgubG9nKDEgKyAoc29uZy5saWtlcyB8fCAwKSkgKiAyO1xuICAgICAgICBzY29yZSArPSBNYXRoLmxvZygxICsgKHNvbmcudmlld3MgfHwgMCkpICogMTtcblxuICAgICAgICAvLyBCb251cyBmb3IgbGlrZWQgc29uZ3NcbiAgICAgICAgaWYgKHVzZXJMaWtlZFNvbmdzLmhhcyhzb25nLmZpbGVfaWQpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gMTA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgc21hbGwgcmFuZG9tbmVzcyB0byBhdm9pZCByZXBldGl0aW9uXG4gICAgICAgIHNjb3JlICs9IE1hdGgucmFuZG9tKCkgKiAyO1xuXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgIHNvbmc6IGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZywgdXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpLCBcbiAgICAgICAgICBzY29yZSBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTb3J0IGJ5IHNjb3JlIGFuZCByZXR1cm4gdG9wIHJlY29tbWVuZGF0aW9uc1xuICAgICAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gc2NvcmVkU29uZ3NcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgICAgICAuc2xpY2UoMCwgMTUpIC8vIEdldCBtb3JlIHNvbmdzIGZvciB2YXJpZXR5XG4gICAgICAgIC5tYXAoZW50cnkgPT4gZW50cnkuc29uZyk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn6egIFNtYXJ0IHJlY29tbWVuZGF0aW9ucyBiYXNlZCBvbiBsaXN0ZW5pbmcgYmVoYXZpb3I6JywgXG4gICAgICAgIHJlY29tbWVuZGF0aW9ucy5zbGljZSgwLCA1KS5tYXAocyA9PiBgJHtzLm5hbWV9IGJ5ICR7cy5hcnRpc3R9YCkpO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBnZXRTbWFydFBlcnNvbmFsaXplZFNvbmdzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29udmVydCBkYXRhYmFzZSBzb25nIHRvIFVJIHNvbmcgZm9ybWF0XG4gIGNvbnN0IGNvbnZlcnREYXRhYmFzZVNvbmcgPSAoZGJTb25nOiBEYXRhYmFzZVNvbmcsIGlzTGlrZWQ6IGJvb2xlYW4gPSBmYWxzZSk6IFNvbmcgPT4gKHtcbiAgICBmaWxlX2lkOiBkYlNvbmcuZmlsZV9pZCxcbiAgICBpbWdfaWQ6IGRiU29uZy5pbWdfaWQsXG4gICAgbmFtZTogZGJTb25nLm5hbWUsXG4gICAgYXJ0aXN0OiBkYlNvbmcuYXJ0aXN0LFxuICAgIGxhbmd1YWdlOiBkYlNvbmcubGFuZ3VhZ2UsXG4gICAgdGFnczogZGJTb25nLnRhZ3MsXG4gICAgdmlld3M6IGRiU29uZy52aWV3cyxcbiAgICBsaWtlczogZGJTb25nLmxpa2VzLFxuICAgIGlkOiBkYlNvbmcuZmlsZV9pZC50b1N0cmluZygpLFxuICAgIGltYWdlOiBgaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvJHtkYlNvbmcuaW1nX2lkfS9wZXhlbHMtcGhvdG8tJHtkYlNvbmcuaW1nX2lkfS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDBgLFxuICAgIGlzTGlrZWRcbiAgfSlcblxuICAvLyBGZXRjaCBhbGwgc29uZ3NcbiAgY29uc3QgZmV0Y2hTb25ncyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHNldFNvbmdzKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGE6IHNvbmdzRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ3ZpZXdzJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgbGV0IHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KClcbiAgICAgIFxuICAgICAgY29uc3QgeyBkYXRhOiBsaWtlZERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdsaWtlZF9zb25ncycpXG4gICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQnKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgXG4gICAgICBpZiAobGlrZWREYXRhKSB7XG4gICAgICAgIHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldChsaWtlZERhdGEubWFwKGl0ZW0gPT4gaXRlbS5zb25nX2lkKSlcbiAgICAgICAgc2V0TGlrZWRTb25ncyh1c2VyTGlrZWRTb25ncylcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29udmVydGVkU29uZ3MgPSBzb25nc0RhdGE/Lm1hcChzb25nID0+IFxuICAgICAgICBjb252ZXJ0RGF0YWJhc2VTb25nKHNvbmcsIHVzZXJMaWtlZFNvbmdzLmhhcyhzb25nLmZpbGVfaWQpKVxuICAgICAgKSB8fCBbXVxuXG4gICAgICBjb25zdCBzb3J0ZWRTb25ncyA9IFsuLi5jb252ZXJ0ZWRTb25nc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBhU2NvcmUgPSBhLnZpZXdzICsgYS5saWtlcztcbiAgICAgICAgY29uc3QgYlNjb3JlID0gYi52aWV3cyArIGIubGlrZXM7XG4gICAgICAgIHJldHVybiBiU2NvcmUgLSBhU2NvcmU7XG4gICAgICB9KTtcblxuICAgICAgc2V0U29uZ3Moc29ydGVkU29uZ3MpO1xuXG4gICAgICBjb25zdCB7IGRhdGE6IHVzZXJEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAuc2VsZWN0KCdsYXN0X3NvbmdfZmlsZV9pZCcpXG4gICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKHVzZXJEYXRhPy5sYXN0X3NvbmdfZmlsZV9pZCkge1xuICAgICAgICBjb25zdCBsYXN0U29uZyA9IGNvbnZlcnRlZFNvbmdzLmZpbmQoc29uZyA9PiBzb25nLmZpbGVfaWQgPT09IHVzZXJEYXRhLmxhc3Rfc29uZ19maWxlX2lkKVxuICAgICAgICBpZiAobGFzdFNvbmcpIHtcbiAgICAgICAgICBzZXRMYXN0UGxheWVkU29uZyhsYXN0U29uZylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzb25nczonLCBlcnJvcilcbiAgICAgIHNldFNvbmdzKFtdKSAvLyBTZXQgZW1wdHkgYXJyYXkgb24gZXJyb3JcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgcGVyc29uYWxpemVkIHNvbmdzIHdpdGggcHJvcGVyIGVycm9yIGhhbmRsaW5nIGFuZCBmaWx0ZXJpbmdcbiAgY29uc3QgZ2V0UGVyc29uYWxpemVkU29uZ3MgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIGN1cnJlbnRTb25nOiBTb25nLCBsaXN0ZW5lZFNvbmdzPzogU2V0PHN0cmluZz4pOiBQcm9taXNlPFNvbmdbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+OtSBGZXRjaGluZyBwZXJzb25hbGl6ZWQgc29uZ3MgZm9yOicsIGN1cnJlbnRTb25nLm5hbWUpO1xuICAgICAgY29uc29sZS5sb2coJ/CfjrUgTGlzdGVuZWQgc29uZ3MgY291bnQ6JywgbGlzdGVuZWRTb25ncz8uc2l6ZSB8fCAwKTtcbiAgICAgIFxuICAgICAgLy8gMS4gRmV0Y2ggYWxsIHNvbmdzIGZyb20gZGF0YWJhc2VcbiAgICAgIGNvbnN0IHsgZGF0YTogc29uZ3NEYXRhLCBlcnJvcjogc29uZ3NFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnKicpO1xuICAgICAgXG4gICAgICBpZiAoc29uZ3NFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgc29uZ3MgZm9yIHBlcnNvbmFsaXphdGlvbjonLCBzb25nc0Vycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXNvbmdzRGF0YSB8fCBzb25nc0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIHNvbmdzIGZvdW5kIGluIGRhdGFiYXNlJyk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gRmV0Y2ggdXNlcidzIGxpc3RlbmluZyBoaXN0b3J5XG4gICAgICBjb25zdCB7IGRhdGE6IGhpc3RvcnlEYXRhLCBlcnJvcjogaGlzdG9yeUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnaGlzdG9yeScpXG4gICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQsIG1pbnV0ZXNfbGlzdGVuZWQnKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpO1xuICAgICAgXG4gICAgICBpZiAoaGlzdG9yeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBoaXN0b3J5OicsIGhpc3RvcnlFcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGhpc3RvcnlNYXAgPSBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpO1xuICAgICAgaWYgKGhpc3RvcnlEYXRhKSB7XG4gICAgICAgIGhpc3RvcnlEYXRhLmZvckVhY2goaCA9PiBoaXN0b3J5TWFwLnNldChoLnNvbmdfaWQsIGgubWludXRlc19saXN0ZW5lZCB8fCAwKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEdldCB1c2VyJ3MgbGlrZWQgc29uZ3NcbiAgICAgIGNvbnN0IHsgZGF0YTogbGlrZWREYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAuc2VsZWN0KCdzb25nX2lkJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKTtcbiAgICAgIFxuICAgICAgY29uc3QgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgbGlrZWREYXRhLmZvckVhY2goaXRlbSA9PiB1c2VyTGlrZWRTb25ncy5hZGQoaXRlbS5zb25nX2lkKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIDQuIEZpbHRlciBhbmQgc2NvcmUgc29uZ3NcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVNvbmdzID0gc29uZ3NEYXRhLmZpbHRlcigoc29uZykgPT4ge1xuICAgICAgICAvLyBFeGNsdWRlIGN1cnJlbnQgc29uZ1xuICAgICAgICBpZiAoc29uZy5maWxlX2lkID09PSBjdXJyZW50U29uZy5maWxlX2lkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBFeGNsdWRlIGxpc3RlbmVkIHNvbmdzIGlmIHByb3ZpZGVkXG4gICAgICAgIGlmIChsaXN0ZW5lZFNvbmdzICYmIGxpc3RlbmVkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZC50b1N0cmluZygpKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5qrIEV4Y2x1ZGluZyBsaXN0ZW5lZCBzb25nOiAke3NvbmcubmFtZX0gYnkgJHtzb25nLmFydGlzdH1gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn461IEF2YWlsYWJsZSBzb25ncyBhZnRlciBmaWx0ZXJpbmc6ICR7YXZhaWxhYmxlU29uZ3MubGVuZ3RofWApO1xuXG4gICAgICBpZiAoYXZhaWxhYmxlU29uZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGF2YWlsYWJsZSBzb25ncyBhZnRlciBmaWx0ZXJpbmcnKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyA1LiBTY29yZSBhbmQgc29ydCBzb25nc1xuICAgICAgY29uc3Qgc2NvcmVkU29uZ3MgPSBhdmFpbGFibGVTb25ncy5tYXAoKHNvbmcpID0+IHtcbiAgICAgICAgbGV0IHNjb3JlID0gMDtcblxuICAgICAgICAvLyBUYWcgbWF0Y2hpbmcgKGhpZ2hlc3QgcHJpb3JpdHkpXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nVGFncyA9IHNvbmcudGFncz8uZmlsdGVyKCh0YWc6IHN0cmluZykgPT5cbiAgICAgICAgICBjdXJyZW50U29uZy50YWdzPy5pbmNsdWRlcyh0YWcpXG4gICAgICAgICkgfHwgW107XG4gICAgICAgIHNjb3JlICs9IG1hdGNoaW5nVGFncy5sZW5ndGggKiAxNTtcblxuICAgICAgICAvLyBBcnRpc3QgbWF0Y2hpbmdcbiAgICAgICAgaWYgKHNvbmcuYXJ0aXN0ID09PSBjdXJyZW50U29uZy5hcnRpc3QpIHtcbiAgICAgICAgICBzY29yZSArPSAyNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExhbmd1YWdlIG1hdGNoaW5nXG4gICAgICAgIGlmIChzb25nLmxhbmd1YWdlID09PSBjdXJyZW50U29uZy5sYW5ndWFnZSkge1xuICAgICAgICAgIHNjb3JlICs9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGlzdGVuaW5nIGhpc3RvcnkgYm9vc3RcbiAgICAgICAgY29uc3QgbGlzdGVuZWRNaW51dGVzID0gaGlzdG9yeU1hcC5nZXQoc29uZy5maWxlX2lkKSB8fCAwO1xuICAgICAgICBzY29yZSArPSBNYXRoLm1pbihsaXN0ZW5lZE1pbnV0ZXMgKiAyLCAyMCk7IC8vIENhcCBhdCAyMCBwb2ludHNcblxuICAgICAgICAvLyBQb3B1bGFyaXR5IGJvb3N0IChsaWtlcyBhbmQgdmlld3MpXG4gICAgICAgIHNjb3JlICs9IE1hdGgubG9nKDEgKyAoc29uZy5saWtlcyB8fCAwKSkgKiAyO1xuICAgICAgICBzY29yZSArPSBNYXRoLmxvZygxICsgKHNvbmcudmlld3MgfHwgMCkpICogMTtcblxuICAgICAgICAvLyBMaWtlZCBzb25ncyBib29zdFxuICAgICAgICBpZiAodXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpIHtcbiAgICAgICAgICBzY29yZSArPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGNvbnRyb2xsZWQgcmFuZG9tbmVzcyB0byBhdm9pZCByZXBldGl0aW9uXG4gICAgICAgIHNjb3JlICs9IE1hdGgucmFuZG9tKCkgKiAzO1xuXG4gICAgICAgIHJldHVybiB7IFxuICAgICAgICAgIHNvbmc6IGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZywgdXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpLCBcbiAgICAgICAgICBzY29yZSBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyA2LiBTb3J0IGJ5IHNjb3JlIGFuZCByZXR1cm4gdG9wIHJlY29tbWVuZGF0aW9uc1xuICAgICAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gc2NvcmVkU29uZ3NcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgICAgICAuc2xpY2UoMCwgMTApIC8vIEdldCBtb3JlIHNvbmdzIHRvIGhhdmUgYSBidWZmZXJcbiAgICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5zb25nKTtcblxuICAgICAgY29uc29sZS5sb2coJ/CfjrUgUGVyc29uYWxpemVkIHJlY29tbWVuZGF0aW9uczonLCByZWNvbW1lbmRhdGlvbnMuc2xpY2UoMCwgNSkubWFwKHMgPT4gYCR7cy5uYW1lfSBieSAke3MuYXJ0aXN0fWApKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn461IFRvdGFsIGF2YWlsYWJsZSBzb25nczonLCBhdmFpbGFibGVTb25ncy5sZW5ndGgpO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBnZXRQZXJzb25hbGl6ZWRTb25nczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9O1xuXG4gIC8vIEZldGNoIHVzZXIgcGxheWxpc3RzXG4gIGNvbnN0IGZldGNoUGxheWxpc3RzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0UGxheWxpc3RzKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogcGxheWxpc3RzRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBsYXlsaXN0X3NvbmdzIChcbiAgICAgICAgICAgIHNvbmdzICgqKVxuICAgICAgICAgIClcbiAgICAgICAgYClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBjb252ZXJ0ZWRQbGF5bGlzdHM6IFBsYXlsaXN0W10gPSBwbGF5bGlzdHNEYXRhPy5tYXAocGxheWxpc3QgPT4ge1xuICAgICAgICBjb25zdCBwbGF5bGlzdFNvbmdzID0gcGxheWxpc3QucGxheWxpc3Rfc29uZ3M/Lm1hcCgocHM6IGFueSkgPT4gXG4gICAgICAgICAgY29udmVydERhdGFiYXNlU29uZyhwcy5zb25ncywgbGlrZWRTb25ncy5oYXMocHMuc29uZ3MuZmlsZV9pZCkpXG4gICAgICAgICkgfHwgW11cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBwbGF5bGlzdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgIG5hbWU6IHBsYXlsaXN0Lm5hbWUsXG4gICAgICAgICAgc29uZ0NvdW50OiBwbGF5bGlzdFNvbmdzLmxlbmd0aCxcbiAgICAgICAgICBpbWFnZTogcGxheWxpc3RTb25nc1swXT8uaW1hZ2UgfHwgJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJyxcbiAgICAgICAgICBzb25nczogcGxheWxpc3RTb25nc1xuICAgICAgICB9XG4gICAgICB9KSB8fCBbXVxuXG4gICAgICBzZXRQbGF5bGlzdHMoY29udmVydGVkUGxheWxpc3RzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwbGF5bGlzdHM6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gVG9nZ2xlIGxpa2Ugc29uZ1xuICBjb25zdCB0b2dnbGVMaWtlID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gIGlmICghdXNlcikgcmV0dXJuO1xuXG4gIGNvbnN0IHNvbmdGaWxlSWQgPSBwYXJzZUludChzb25nSWQpO1xuICBjb25zdCBpc0N1cnJlbnRseUxpa2VkID0gbGlrZWRTb25ncy5oYXMoc29uZ0ZpbGVJZCk7XG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNDdXJyZW50bHlMaWtlZCkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gbGlrZWRfc29uZ3NcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdsaWtlZF9zb25ncycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICAuZXEoJ3NvbmdfaWQnLCBzb25nRmlsZUlkKTtcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgICAgLy8gRGVjcmVtZW50IGxpa2VzXG4gICAgICBhd2FpdCBzdXBhYmFzZS5ycGMoJ2RlY3JlbWVudF9zb25nX2xpa2VzJywgeyBzb25nX2ZpbGVfaWQ6IHNvbmdGaWxlSWQgfSk7XG5cbiAgICAgIHNldExpa2VkU29uZ3MocHJldiA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1NldCA9IG5ldyBTZXQocHJldik7XG4gICAgICAgIG5ld1NldC5kZWxldGUoc29uZ0ZpbGVJZCk7XG4gICAgICAgIHJldHVybiBuZXdTZXQ7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIHRvIGxpa2VkX3NvbmdzXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgICAgIHNvbmdfaWQ6IHNvbmdGaWxlSWQsXG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXG4gICAgICAvLyBJbmNyZW1lbnQgbGlrZXNcbiAgICAgIGF3YWl0IHN1cGFiYXNlLnJwYygnaW5jcmVtZW50X3NvbmdfbGlrZXMnLCB7IHNvbmdfZmlsZV9pZDogc29uZ0ZpbGVJZCB9KTtcblxuICAgICAgc2V0TGlrZWRTb25ncyhwcmV2ID0+IG5ldyBTZXQocHJldikuYWRkKHNvbmdGaWxlSWQpKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc29uZ3Mgc3RhdGVcbiAgICAvLyBVcGRhdGUgc29uZ3Mgc3RhdGVcbnNldFNvbmdzKHByZXZTb25ncyA9PlxuICBwcmV2U29uZ3MubWFwKHNvbmcgPT5cbiAgICBzb25nLmlkID09PSBzb25nSWRcbiAgICAgID8ge1xuICAgICAgICAgIC4uLnNvbmcsXG4gICAgICAgICAgaXNMaWtlZDogIWlzQ3VycmVudGx5TGlrZWQsXG4gICAgICAgICAgbGlrZXM6IHNvbmcubGlrZXMgKyAoaXNDdXJyZW50bHlMaWtlZCA/IC0xIDogMSksXG4gICAgICAgIH1cbiAgICAgIDogc29uZ1xuICApXG4pO1xuXG5cbiAgICAvLyBVcGRhdGUgcGxheWxpc3RzIHN0YXRlXG4gICAgc2V0UGxheWxpc3RzKHByZXZQbGF5bGlzdHMgPT5cbiAgICAgIHByZXZQbGF5bGlzdHMubWFwKHBsYXlsaXN0ID0+ICh7XG4gICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICBzb25nczogcGxheWxpc3Quc29uZ3MubWFwKHNvbmcgPT5cbiAgICAgICAgICBzb25nLmlkID09PSBzb25nSWRcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIC4uLnNvbmcsXG4gICAgICAgICAgICAgICAgaXNMaWtlZDogIWlzQ3VycmVudGx5TGlrZWQsXG4gICAgICAgICAgICAgICAgbGlrZXM6IHNvbmcubGlrZXMgKyAoaXNDdXJyZW50bHlMaWtlZCA/IC0xIDogMSksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogc29uZ1xuICAgICAgICApLFxuICAgICAgfSkpXG4gICAgKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB0b2dnbGluZyBsaWtlOicsIGVycm9yKTtcbiAgfVxufTtcblxuXG4gIC8vIENyZWF0ZSBwbGF5bGlzdFxuICBjb25zdCBjcmVhdGVQbGF5bGlzdCA9IGFzeW5jIChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSlcbiAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIGNvbnN0IG5ld1BsYXlsaXN0OiBQbGF5bGlzdCA9IHtcbiAgICAgICAgaWQ6IGRhdGEuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICBzb25nQ291bnQ6IDAsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnLFxuICAgICAgICBzb25nczogW11cbiAgICAgIH1cblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gWy4uLnByZXYsIG5ld1BsYXlsaXN0XSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIHBsYXlsaXN0XG4gIGNvbnN0IGRlbGV0ZVBsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ2lkJywgcGFyc2VJbnQocGxheWxpc3RJZCkpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gcHJldi5maWx0ZXIocGxheWxpc3QgPT4gcGxheWxpc3QuaWQgIT09IHBsYXlsaXN0SWQpKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBSZW5hbWUgcGxheWxpc3RcbiAgY29uc3QgcmVuYW1lUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAudXBkYXRlKHsgbmFtZTogbmV3TmFtZSB9KVxuICAgICAgICAuZXEoJ2lkJywgcGFyc2VJbnQocGxheWxpc3RJZCkpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKHBsYXlsaXN0ID0+IFxuICAgICAgICAgIHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkIFxuICAgICAgICAgICAgPyB7IC4uLnBsYXlsaXN0LCBuYW1lOiBuZXdOYW1lIH1cbiAgICAgICAgICAgIDogcGxheWxpc3RcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5hbWluZyBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgc29uZyB0byBwbGF5bGlzdFxuICBjb25zdCBhZGRTb25nVG9QbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIHNvbmc6IFNvbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdF9zb25ncycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHBsYXlsaXN0X2lkOiBwYXJzZUludChwbGF5bGlzdElkKSxcbiAgICAgICAgICBzb25nX2lkOiBzb25nLmZpbGVfaWRcbiAgICAgICAgfSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAocGxheWxpc3QgPT4ge1xuICAgICAgICAgIGlmIChwbGF5bGlzdC5pZCA9PT0gcGxheWxpc3RJZCkge1xuICAgICAgICAgICAgY29uc3Qgc29uZ0V4aXN0cyA9IHBsYXlsaXN0LnNvbmdzLnNvbWUocyA9PiBzLmlkID09PSBzb25nLmlkKVxuICAgICAgICAgICAgaWYgKCFzb25nRXhpc3RzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTb25ncyA9IFsuLi5wbGF5bGlzdC5zb25ncywgc29uZ11cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5wbGF5bGlzdCxcbiAgICAgICAgICAgICAgICBzb25nczogdXBkYXRlZFNvbmdzLFxuICAgICAgICAgICAgICAgIHNvbmdDb3VudDogdXBkYXRlZFNvbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbWFnZTogdXBkYXRlZFNvbmdzWzBdPy5pbWFnZSB8fCBwbGF5bGlzdC5pbWFnZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwbGF5bGlzdFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgc29uZyB0byBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgc29uZyBmcm9tIHBsYXlsaXN0XG4gIGNvbnN0IHJlbW92ZVNvbmdGcm9tUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nLCBzb25nSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0X3NvbmdzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgncGxheWxpc3RfaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCdzb25nX2lkJywgcGFyc2VJbnQoc29uZ0lkKSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAocGxheWxpc3QgPT4ge1xuICAgICAgICAgIGlmIChwbGF5bGlzdC5pZCA9PT0gcGxheWxpc3RJZCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNvbmdzID0gcGxheWxpc3Quc29uZ3MuZmlsdGVyKHNvbmcgPT4gc29uZy5pZCAhPT0gc29uZ0lkKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ucGxheWxpc3QsXG4gICAgICAgICAgICAgIHNvbmdzOiB1cGRhdGVkU29uZ3MsXG4gICAgICAgICAgICAgIHNvbmdDb3VudDogdXBkYXRlZFNvbmdzLmxlbmd0aCxcbiAgICAgICAgICAgICAgaW1hZ2U6IHVwZGF0ZWRTb25nc1swXT8uaW1hZ2UgfHwgJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGxheWxpc3RcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3Zpbmcgc29uZyBmcm9tIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBsYXN0IHNvbmcgaW4gdXNlciBwcm9maWxlXG4gIGNvbnN0IHVwZGF0ZUxhc3RTb25nID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcnMnKVxuICAgICAgICAudXBkYXRlKHsgbGFzdF9zb25nX2ZpbGVfaWQ6IHBhcnNlSW50KHNvbmdJZCkgfSlcbiAgICAgICAgLmVxKCdpZCcsIHVzZXIuaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgbGFzdCBzb25nOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlY29yZCBsaXN0ZW5pbmcgaGlzdG9yeSB3aXRoIHByb3BlciB0aW1lIHRyYWNraW5nXG4gIGNvbnN0IHJlY29yZExpc3RlbmluZ0hpc3RvcnkgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgLy8gSWYgdGhlcmUncyBhIHByZXZpb3VzIHNvbmcgcGxheWluZywgcmVjb3JkIGl0cyBsaXN0ZW5pbmcgdGltZVxuICAgICAgaWYgKGN1cnJlbnRTb25nUmVmLmN1cnJlbnQgJiYgY3VycmVudFNvbmdTdGFydFRpbWUpIHtcbiAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBtaW51dGVzTGlzdGVuZWQgPSAoZW5kVGltZS5nZXRUaW1lKCkgLSBjdXJyZW50U29uZ1N0YXJ0VGltZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCk7XG5cbiAgICBpZiAobWludXRlc0xpc3RlbmVkID4gMC4xKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZChtaW51dGVzTGlzdGVuZWQgKiAxMDApIC8gMTAwO1xuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5ycGMoJ3Vwc2VydF9oaXN0b3J5X21pbnV0ZXMnLCB7XG4gICAgICAgICAgdXNlcl91dWlkOiB1c2VyLmlkLFxuICAgICAgICAgIHNvbmdfZmlsZV9pZDogcGFyc2VJbnQoY3VycmVudFNvbmdSZWYuY3VycmVudCksXG4gICAgICAgICAgbWludXRlczogbWludXRlcyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHJlY29yZGluZyBzb25nIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgSGlzdG9yeSB1cGRhdGVkOiArJHttaW51dGVzfSBtaW5zIGZvciBzb25nICR7Y3VycmVudFNvbmdSZWYuY3VycmVudH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVjb3JkaW5nIHByZXZpb3VzIHNvbmcgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAgIC8vIFNldCBuZXcgc29uZyBhcyBjdXJyZW50XG4gICAgY3VycmVudFNvbmdSZWYuY3VycmVudCA9IHNvbmdJZFxuICAgIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lKG5ldyBEYXRlKCkpXG4gICAgXG4gICAgLy8gVXBkYXRlIGxhc3Qgc29uZyBpbiB1c2VyIHByb2ZpbGVcbiAgICBhd2FpdCB1cGRhdGVMYXN0U29uZyhzb25nSWQpXG50cnkge1xuICBhd2FpdCBzdXBhYmFzZS5ycGMoJ2luY3JlbWVudF9zb25nX3ZpZXdzJywgeyBzb25nX2ZpbGVfaWQ6IHBhcnNlSW50KHNvbmdJZCkgfSk7XG59IGNhdGNoIChlcnJvcikge1xuICBjb25zb2xlLmVycm9yKCdFcnJvciBpbmNyZW1lbnRpbmcgc29uZyB2aWV3czonLCBlcnJvcik7XG59XG5cbiAgfVxuXG4gIC8vIFN0b3AgY3VycmVudCBzb25nIHRyYWNraW5nICh3aGVuIHBsYXllciBpcyBjbG9zZWQpXG4gIGNvbnN0IHN0b3BDdXJyZW50U29uZ1RyYWNraW5nID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChjdXJyZW50U29uZ1JlZi5jdXJyZW50ICYmIGN1cnJlbnRTb25nU3RhcnRUaW1lICYmIHVzZXIpIHtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpXG4gICAgICBjb25zdCBtaW51dGVzTGlzdGVuZWQgPSAoZW5kVGltZS5nZXRUaW1lKCkgLSBjdXJyZW50U29uZ1N0YXJ0VGltZS5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MClcbiAgICAgIFxuICAgICAgaWYgKG1pbnV0ZXNMaXN0ZW5lZCA+IDAuMSkge1xuICB0cnkge1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLnJvdW5kKG1pbnV0ZXNMaXN0ZW5lZCAqIDEwMCkgLyAxMDA7XG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCd1cHNlcnRfaGlzdG9yeV9taW51dGVzJywge1xuICAgICAgdXNlcl91dWlkOiB1c2VyLmlkLFxuICAgICAgc29uZ19maWxlX2lkOiBwYXJzZUludChjdXJyZW50U29uZ1JlZi5jdXJyZW50KSxcbiAgICAgIG1pbnV0ZXM6IG1pbnV0ZXMsXG4gICAgfSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZWNvcmRpbmcgc29uZyBoaXN0b3J5IG9uIHN0b3A6JywgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhg8J+bkSBIaXN0b3J5IHVwZGF0ZWQgb24gc3RvcDogKyR7bWludXRlc30gbWlucyBmb3Igc29uZyAke2N1cnJlbnRTb25nUmVmLmN1cnJlbnR9YCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlY29yZGluZyBmaW5hbCBzb25nIGhpc3Rvcnk6JywgZXJyb3IpO1xuICB9XG59XG5cbiAgICB9XG5cbiAgICBjdXJyZW50U29uZ1JlZi5jdXJyZW50ID0gbnVsbFxuICAgIHNldEN1cnJlbnRTb25nU3RhcnRUaW1lKG51bGwpXG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvYWREYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgIC8vIFJlc2V0IGRhdGEgd2hlbiB1c2VyIGxvZ3Mgb3V0XG4gICAgICAgIHNldFNvbmdzKFtdKVxuICAgICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgICAgIHNldExpa2VkU29uZ3MobmV3IFNldCgpKVxuICAgICAgICBzZXRMYXN0UGxheWVkU29uZyhudWxsKVxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbZmV0Y2hTb25ncygpLCBmZXRjaFBsYXlsaXN0cygpXSlcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgZGF0YTonLCBlcnJvcilcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9hZERhdGEoKVxuICB9LCBbdXNlcl0pXG5cbiAgcmV0dXJuIHtcbiAgICBzb25ncyxcbiAgICBwbGF5bGlzdHMsXG4gICAgbGlrZWRTb25nczogc29uZ3MuZmlsdGVyKHNvbmcgPT4gc29uZy5pc0xpa2VkKSxcbiAgICBsYXN0UGxheWVkU29uZyxcbiAgICBsb2FkaW5nLFxuICAgIHRvZ2dsZUxpa2UsXG4gICAgY3JlYXRlUGxheWxpc3QsXG4gICAgZGVsZXRlUGxheWxpc3QsXG4gICAgcmVuYW1lUGxheWxpc3QsXG4gICAgYWRkU29uZ1RvUGxheWxpc3QsXG4gICAgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCxcbiAgICByZWNvcmRMaXN0ZW5pbmdIaXN0b3J5LFxuICAgIHN0b3BDdXJyZW50U29uZ1RyYWNraW5nLFxuICAgIHJlZnJlc2hEYXRhOiAoKSA9PiB7XG4gICAgICBmZXRjaFNvbmdzKClcbiAgICAgIGZldGNoUGxheWxpc3RzKClcbiAgICB9LFxuICAgIGdldFBlcnNvbmFsaXplZFNvbmdzLFxuICAgIGdldFNtYXJ0UGVyc29uYWxpemVkU29uZ3NcbiAgfVxufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInN1cGFiYXNlIiwidXNlU3VwYWJhc2VEYXRhIiwidXNlciIsInNvbmdzIiwic2V0U29uZ3MiLCJwbGF5bGlzdHMiLCJzZXRQbGF5bGlzdHMiLCJsaWtlZFNvbmdzIiwic2V0TGlrZWRTb25ncyIsIlNldCIsImxhc3RQbGF5ZWRTb25nIiwic2V0TGFzdFBsYXllZFNvbmciLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImN1cnJlbnRTb25nU3RhcnRUaW1lIiwic2V0Q3VycmVudFNvbmdTdGFydFRpbWUiLCJjdXJyZW50U29uZ1JlZiIsImdldFNtYXJ0UGVyc29uYWxpemVkU29uZ3MiLCJ1c2VySWQiLCJsaXN0ZW5lZFNvbmdzSW5CYXRjaCIsImV4Y2x1ZGVTb25ncyIsImNvbnNvbGUiLCJsb2ciLCJtYXAiLCJzIiwibmFtZSIsImxlbmd0aCIsInByZWZlcnJlZFRhZ3MiLCJwcmVmZXJyZWRBcnRpc3RzIiwiZm9yRWFjaCIsInNvbmciLCJ0YWdzIiwidGFnIiwiYWRkIiwidG9Mb3dlckNhc2UiLCJhcnRpc3QiLCJBcnJheSIsImZyb20iLCJkYXRhIiwic29uZ3NEYXRhIiwiZXJyb3IiLCJzb25nc0Vycm9yIiwic2VsZWN0Iiwid2FybiIsImxpa2VkRGF0YSIsImVxIiwidXNlckxpa2VkU29uZ3MiLCJpdGVtIiwic29uZ19pZCIsImF2YWlsYWJsZVNvbmdzIiwiZmlsdGVyIiwiaGFzIiwiZmlsZV9pZCIsInRvU3RyaW5nIiwic2NvcmVkU29uZ3MiLCJzY29yZSIsInNvbmdUYWdzIiwibWF0Y2hpbmdUYWdzIiwibGlzdGVuZWRMYW5ndWFnZXMiLCJsYW5ndWFnZSIsImluY2x1ZGVzIiwiTWF0aCIsImxpa2VzIiwidmlld3MiLCJyYW5kb20iLCJjb252ZXJ0RGF0YWJhc2VTb25nIiwicmVjb21tZW5kYXRpb25zIiwic29ydCIsImEiLCJiIiwic2xpY2UiLCJlbnRyeSIsImRiU29uZyIsImlzTGlrZWQiLCJpbWdfaWQiLCJpZCIsImltYWdlIiwiZmV0Y2hTb25ncyIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiY29udmVydGVkU29uZ3MiLCJzb3J0ZWRTb25ncyIsImFTY29yZSIsImJTY29yZSIsInVzZXJEYXRhIiwic2luZ2xlIiwibGFzdF9zb25nX2ZpbGVfaWQiLCJsYXN0U29uZyIsImZpbmQiLCJnZXRQZXJzb25hbGl6ZWRTb25ncyIsImN1cnJlbnRTb25nIiwibGlzdGVuZWRTb25ncyIsInNpemUiLCJoaXN0b3J5RGF0YSIsImhpc3RvcnlFcnJvciIsImhpc3RvcnlNYXAiLCJNYXAiLCJoIiwic2V0IiwibWludXRlc19saXN0ZW5lZCIsImxpc3RlbmVkTWludXRlcyIsImdldCIsIm1pbiIsImZldGNoUGxheWxpc3RzIiwicGxheWxpc3RzRGF0YSIsImNvbnZlcnRlZFBsYXlsaXN0cyIsInBsYXlsaXN0IiwicGxheWxpc3RTb25ncyIsInBsYXlsaXN0X3NvbmdzIiwicHMiLCJzb25nQ291bnQiLCJ0b2dnbGVMaWtlIiwic29uZ0lkIiwic29uZ0ZpbGVJZCIsInBhcnNlSW50IiwiaXNDdXJyZW50bHlMaWtlZCIsImRlbGV0ZSIsInJwYyIsInNvbmdfZmlsZV9pZCIsInByZXYiLCJuZXdTZXQiLCJpbnNlcnQiLCJ1c2VyX2lkIiwicHJldlNvbmdzIiwicHJldlBsYXlsaXN0cyIsImNyZWF0ZVBsYXlsaXN0IiwibmV3UGxheWxpc3QiLCJkZWxldGVQbGF5bGlzdCIsInBsYXlsaXN0SWQiLCJyZW5hbWVQbGF5bGlzdCIsIm5ld05hbWUiLCJ1cGRhdGUiLCJhZGRTb25nVG9QbGF5bGlzdCIsInBsYXlsaXN0X2lkIiwic29uZ0V4aXN0cyIsInNvbWUiLCJ1cGRhdGVkU29uZ3MiLCJyZW1vdmVTb25nRnJvbVBsYXlsaXN0IiwidXBkYXRlTGFzdFNvbmciLCJyZWNvcmRMaXN0ZW5pbmdIaXN0b3J5IiwiY3VycmVudCIsImVuZFRpbWUiLCJEYXRlIiwibWludXRlc0xpc3RlbmVkIiwiZ2V0VGltZSIsIm1pbnV0ZXMiLCJyb3VuZCIsInVzZXJfdXVpZCIsInN0b3BDdXJyZW50U29uZ1RyYWNraW5nIiwibG9hZERhdGEiLCJQcm9taXNlIiwiYWxsIiwicmVmcmVzaERhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSupabaseData.ts\n"));

/***/ })

});